# 正则表达式

## 声明一个正则

```JavaScript
const regexp = /a/g
const regexp = new RegExp('a','g');
const regexp = new RegExp(/a/,'g')
```

## 字符串能使用正则的方法

```JavaScript
let a = 'aaa';
let b = /a/
//匹配第一次出现的位置
a.search(b); //0
//替换
a.replace(b,'c') //caa
//匹配
a.match(b) //["a", index: 0, input: "aaa", groups: undefined] 未匹配则返回null
//
```

## 正则表达式的方法

```JavaScript
//匹配参数是否存在
let a = 'aaa';
let b = /a/;
b.test(a)//true
```

## 模式匹配

```JavaScript
var str = "abc123def";
var patt1 = /[0-9]+/;
str.match(patt1); //123
```

## 限定符

默认 + * 都少贪婪匹配,会尽可能的匹配更多的字符,在+或者*后面加上?,则会最小匹配

1. **+** 前面的字符至少出现一次

   ```JavaScript
   /ruo+b/ ; //匹配 ruob ruoob ruooob
   /[ruo]+b/ //匹配 ruob ruoruob
   ```

2. **\*** 前面的字符出现任意次

   ```JavaScript
   /ruo*b/ //匹配 rub ruob ruoob
   ```

3. **?** 前面的字符最多只能出现一次

   ```JavaScript
   /ruo?b/ //匹配 ruob rub
   ```

4. {n} 前面的字符必须出现确定的 n 次

5. {n,} 前面的字符至少出现 n 次

6. {n,m} 前面的字符出现 n 到 m 次

## 特殊字符

1. \s 匹配任何空白字符

2. \s 匹配任何非空白字符

3. **^** 匹配字符串的开始位置

4. **\$** 匹配字符串的结尾位置

5. <font color="red">**.**</font> 匹配 除了换行符的任何字符

6. | 匹配两者之一

   ```JavaScript
   /^[a|b]+c/ //匹配a或者b开头,然后出现任意个a或者b,跟着c  ababac aaaac bbbc
   ```

## 匹配 dom

```JavaScript
'<html>123</html>'.match(/^<html>(.*)<\/html>$/)
```

## 注意

1. 圆括号()是组，主要应用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理
2. **方括号是单个匹配**，字符集/排除字符集/命名字符集
