# 重要知识点

## 文件结构

```shell
- src
 +- assets 《---- 静态资源存放的目录
 +- components 《---- 我们写的可重用的组件
 +- pages 《--- -组件化的页面
 +- router 《---- 路由配置
 +- store 《---- 状态管理
 +- views 《---- 路由
```



## model

在vmodel用来绑定input的时候,默认情况下就相当于model的event等于input,prop等于value

```vue
//如以下代码
<template>
  <div id="app">
    <h1>{{ text }}</h1>
    <!--双向绑定传入参数text,相当于-->
    <!--   :text='text' @myinput='value=>text=value' -->
    <model-input v-model="text"></model-input>
  </div>
</template>

<script>
export default {
  data() {
    return {
      text: '',
    };
  },
  components: {
    modelInput: {
      model: {
        //监听子组件中注册的事件myinput
        event: 'myinput',
        //这里绑定的prop是子组件中的text
        prop: 'text',
      },
      props: {
        text: {
          type:String,
          default:''
        },
      },
      template: `
        <input type="text" @input="this.$emit('myinput', e.target.value)" />
      `,
    },
  },
};
</script>
```

## 事件修饰符

```vue
  <a v-on:click.once="doThis">点击只触发一次</a>
  <input @keyup.enter="submit" type="text" />
  <button @click.left="leftdo">left onclick</button>
  <button @click.middle="middledo">middle onclick</button>
```

## watch监听

```vue
<script>
new Vue({
  data(){
    return {
      text:'',
      result:''
    }
  },
  watch:{
    //设置与data属性同名的函数来监听该属性,在属性变化的时候触发函数
    text(){
      this.result = text
    }
  }
})
</script>
```

## v-bind绑定多个

**如果子组件的props中直接绑定对象在使用就会好很多,**<font color='red'>但是受限于vue不能进行参数校验,</font>**直接绑定对象更加简便,绑定多个值再用v-bind='some',产生的项目会更加稳定**

```vue
<!--这里一次性会绑定两个-->
<my-child v-bind='post'></my-child>
<script>
  Vue.componet('myChild',{
    props:{
      id:number,
      title:string
    }
  })
  new Vue({
    data(){
      return {
        post:{
          id:1,
          title:'hello, world'
        }
      }
    }
  })
</script>
```



## transition

当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 <transition> 组件中的多个元素设置 key 是一个更好的实践。

<!-- transition代码样式提示 -->

<img src="https://vuejs.bootcss.com/images/transition.png"></img>

注意的是必须绑定 key 不然 vue 会复用组件,从而不产生动画

```html
<transition>
  <button v-if="isEditing" key="save">
    Save
  </button>
  <button v-else key="edit">
    Edit
  </button>
</transition>
```

可以简写为

```html
<transition>
  <button :key="isEditing">
    {{isEditing?Save:Edit}}
  </button>
</transition>
```

过渡模式 in-out：新元素先进行过渡，完成之后当前元素过渡离开。out-in：当前元素先进行过渡，完成之后新元素过渡进入。

### 多组件过渡

```html
<style>
  .component-fade-enter-active,
  .component-fade-leave-active {
    transition: opacity 0.3s ease;
  }
  .component-fade-enter, .component-fade-leave-to
/* .component-fade-leave-active for below version 2.1.8 */ {
    opacity: 0;
  }
</style>
<transition name="component-fade" mode="out-in">
  <component v-bind:is="view"></component>
</transition>
<script>
  new Vue({
    el: '#transition-components-demo',
    data: {
      view: 'v-a',
    },
    components: {
      'v-a': {
        template: '<div>Component A</div>',
      },
      'v-b': {
        template: '<div>Component B</div>',
      },
    },
  });
</script>
```

## is 动态组件绑定

```vue
<template>
  <component :is="childName"></component>
</template>
<script>
import topNav from './topNav';
import topAd from './topAd';
export default {
  data() {
    return {
      childName: 'topNav',
    };
  },
  components: {
    topNav,
    topAd,
  },
};
</script>
```

## 混入

混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。

```javascript
var myMixin = {
  created: function () {
    this.hello();
  },
  methods: {
    hello: function () {
      console.log('hello from mixin!');
    },
  },
};

// 定义一个使用混入对象的组件
var Component = Vue.extend({
  mixins: [myMixin],
});

var component = new Component(); // => "hello from mixin!"
```

### 选项合并

当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。

比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先

```javascript
let mix = {
  data() {
    return {
      message: 'hello',
    };
  },
  methods: {
    sayHi() {
      console.log('hi');
    },
    sayData() {
      console.log(this.$data);
    },
  },
  created() {
    this.sayData();
  },
};
new Vue({
  mixins: [mix],
  data() {
    return {
      msg: 'world',
    };
  },
  created() {
    console.log('我是newvue'); //同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 形式如created:[]
  },
  methods: {
    sayHi() {
      console.log('我是组件'); //值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。
    },
  },
}).$mount('#app');
```

### 全局混入

也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。

// 为自定义的选项 'myOption' 注入一个处理器。

```javascript
Vue.mixin({
  created() {
    var myOption = this.$options.myOption;
    if (myOption) {
      console.log(myOption);
    }
  },
});

new Vue({
  myOption: 'hello!',
});
// => "hello!"
```

谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用

## 自定义指令

除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。

```javascript
new Vue({
  directives: {
    focus: {
      inserted(el) {
        el.focus();
      },
      bind(el) {
        el.value = 'hello world';
      },
    },
  },
}).$mount('#app');
```

### 钩子函数

一个指令定义对象可以提供如下几个钩子函数 (均为可选)：

1. `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。

2. `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。

3. `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。

4. `componentUpdated`：指令所在组件的 VNode 及其子 VNode 全部更新后调用。

5. `unbind`：只调用一次，指令与元素解绑时调用。

### 钩子函数参数

1. el：指令所绑定的元素，可以用来直接操作 DOM 。
2. binding：一个对象，包含以下属性： 1. name：指令名，不包括 v- 前缀。
   1. value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
   1. oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
   1. expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
   1. arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
   1. modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。
3. vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
4. oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。

## 渲染函数 & JSX

### 基础

```javascript
Vue.component('anchored-heading', {
  render(h) {
    return h(
      'h' + this.level, // 标签名称
      this.$slots.default
    ); //子元素数组
  },
  props: {
    level: {
      type: Number,
      required: true,
    },
  },
});
new Vue({}).$mount('#app');
```

### 节点、树以及虚拟 DOM

```javascript
new Vue({
  data() {
    return {
      blogTitle: 'i am title',
    };
  },
  components: {
    'blog-title': {
      render(h) {
        return h('h1', this.btitle);
      }, //注意的是,如果要使用this就不能使用箭头函数h=>h(app)
      props: { btitle: { type: String } },
    },
  },
}).$mount('#app');
```

**虚拟 DOM**

```javascript
return h('h1', this.blogTitle);
//h会返回一个,不是实际的dom元素,它的名字是createNodeDescription,因为他包含的信息会告诉vue需要渲染什么节点,及其子节点,所以它的名字是虚拟节点,简称VNode
```

**createElement 参数**(就是 h 函数)

```javascript
// @returns {VNode}
createElement(
  // {String | Object | Function}
  // 一个 HTML 标签字符串，组件选项对象，或者
  // 解析上述任何一种的一个 async 异步函数。必需参数。
  'div',

  // {Object}
  // 一个包含模板相关属性的数据对象
  // 你可以在 template 中使用这些特性。可选参数。
  {
    // (详情见下一节)
  },

  // {String | Array}
  // 子虚拟节点 (VNodes)，由 `createElement()` 构建而成，
  // 也可以使用字符串来生成“文本虚拟节点”。可选参数。
  [
    '先写一些文字',
    createElement('h1', '一则头条'),
    createElement(MyComponent, {
      props: {
        someProp: 'foobar',
      },
    }),
  ]
);
```

**使用 JavaScript 代替模板功能**

```javascript
//代替vif vfor
let vm = new Vue({
  data() {
    return {
      blogTitle: 'i am title',
      items: [],
    };
  },
  render(h) {
    if (this.items.length) {
      return h(
        'ul',
        this.items.map((item) => h('li', item))
      );
    } else {
      return h('p', 'fuck');
    }
  },
}).$mount('#app');

//代替v-model
let vm = new Vue({
  data() {
    return {
      blogTitle: 'i am title',
      items: [],
    };
  },
  render(h) {
    let self = this;
    return h('div', [
      h('h1', this.blogTitle),
      h('input', {
        domProps: { value: self.blogTitle },
        on: {
          input(e) {
            self.blogTitle = e.target.value;
          },
        },
      }),
    ]);
  },
}).$mount('#app');

//静态插槽
Vue.component('v-a', {
  render(h) {
    return h('div', this.$slots.default);
  },
});
let vm = new Vue({
  data() {
    return {
      blogTitle: 'i am title',
      items: [],
    };
  },
}).$mount('#app');
//作用域插槽
Vue.component('v-a', {
  render(h) {
    return h('div', [
      this.$scopedSlots.default({
        text: this.message,
      }),
    ]);
  },
});
let vm = new Vue({
  data() {
    return {
      blogTitle: 'i am title',
      items: [],
    };
  },
}).$mount('#app');
```

[事件修饰符查询](https://vuejs.bootcss.com/v2/guide/render-function.html#%E4%BA%8B%E4%BB%B6-amp-%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6)