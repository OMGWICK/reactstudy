## getComputedStyle

getComputedStyle(element,pseudoEit);

1. Element 获取到这个 DOM 的所有 css 样式
2. pseudoedit 指定要匹配的伪元素

属性就是 css 样式,例如 widht height 能直接获取到计算后的样式

## 顶级 await top-level await

正常的 await 必须在 async 函数中使用,但是将当前 ts 为模块的时候,能在顶级作用域中
直接使用 await 例如 const response = await fetch('...');

## setTimeout 最小时间

```javascript
//setTimeout有最小时间限制4ms(但是实际上取决于你的机器运行,有可能会更少),所以0和1其实没区别
function a() {
  setTimeout(function () {
    console.log(1);
  }, 1);
  setTimeout(function () {
    console.log(2);
  }, 0);
  console.log(3);
}
a();
```

## 事件监听默认为冒泡阶段触发

```html
<div id="box1">
  触发box2
  <div id="box2">
    content
  </div>
</div>
<script>
  //默认为false
  const $ = document.querySelector.bind(document);
  const box1 = $('#box1');
  const box2 = $('#box2');
  box1.addEventListener(
    'click',
    () => {
      console.log('box1 true');
    },
    true
  );
  box1.addEventListener(
    'click',
    () => {
      console.log('box1 false');
    },
    false
  );
  box2.addEventListener(
    'click',
    () => {
      console.log('box2 true');
    },
    true
  );
  box2.addEventListener(
    'click',
    () => {
      console.log('box2 false');
    },
    false
  );
  //box1 true, box2 true, box2 false, box1 false
</script>
```

## 以下哪些工具可用来打包构建前端项目

1. gulp
2. webpack
3. rollup
4. grunt

## 已知一棵二叉树的前序遍历为 CABEFDHG，中序遍历为 BAFECHDG，那么它的后序遍历是

BFEAHGDC

## 以下关于 TCP/IP、UDP、HTTP 描述正确的是

1. UDP 是面向无连接的,不可靠的数据报服务
2. TCP 是面向连接的,可靠的字节流服务
3. HTTP 是应用层协议

## HTTP 协议中，请求永久重定向的状态码为

1. 301 永久重定向
2. 302 临时重定向

## html5 可以使用 data-\*来自定义属性

## String('a') === 'a'

## 表单上传文件的 enctype 设置为什么?

multipart/form-data

## h1 颜色是什么

```html
<article id="post" class="content">
  <h1 class="title">360公司简介</h1>
</article>
<style>
  #post {
    color: blue;
  }
  h1.title {
    color: black;
  }
  .content .title {
    color: red;
  }
  article h1 {
    color: green;
  }
</style>
<!-- 红色 -->
```

**继承相当于 0**

1. id 选择器权重 100
2. class 选择器权重 10
3. 元素选择器权重 1

## 让一个元素内的文字不换行

```css
a {
  word-break: keep-all; /* 不换行 */
  white-space: nowrap; /* 不换行 */
  overflow: hidden; /* 内容超出宽度时隐藏超出部分的内容 */
  text-overflow: ellipsis; /* 溢出时显示省略标记...；需与overflow:hidden;一起使用*/
}
```

## for in

遍历可枚举属性 包括原型链,尽量不要遍历数组

## 通过 JavaScript 设置 Cookie，如果不指定 expires，会产生以下哪种结果（）

在浏览器会话结束后失效

## break

能够跳出 while for switch 循环

## 删除排序数组中的重复项

给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回
移除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件
下完成。 **不需要考虑超出新长度以后的元素**

```javascript
function deleAry(ary) {
  const len = ary.length;
  let i = 0,
    j = 1;
  while (j < len) {
    if (ary[i] !== ary[j]) {
      ary[i + 1] = ary[j];
      i++;
    }
    j++;
  }
  return i + 1;
}
```

## typeof 有哪些返回值

1. object
2. function
3. undefined
4. number
5. string
6. boolean
7. symbol

## Number(10) 和 new Number(10)区别

Number 相当于做了类型转换 new Number(10) 构造函数创建返回对象

```javascript
Number(10) === 10; //true
new Number(10) === 10; //false
10 instanceof Number; //false
```

## sessionStorage,localStorage

storage 分 localStorage 永久级别和 sessionStorage 会话级别，两者的存储空间都为
5MB。两者都存在跨域限制。

## ajax 和 axios、fetch 三个对象中，没有使用 XMLHttpRequest 对象的是

fetch fetch 是使用的 es 新规范

## 分析http://hui.m.fenqile.com域名

顶级域名 com 二级域名 fenqile.com 三级域名 m.fenqile.com 四级域名
hui.m.fenqile.com

## 查看当前代码在 git 服务器的分支列表

git branch -r

## 以下关于事件监听器的说法正确的是

e.target 获取的是直接**触发**监听器的 DOM 元素

## 会修改原数组的方法,副作用方法

1. sort
2. reverse
3. splice
4. push
5. pop
6. shift
7. unshift

## 如下哪种前端构建技术可以剔除 Javascript 中没有被使用的代码？

1. Tree shaking (晃动树)

## 以下代码能在不同环境下（不考虑兼容性问题）正确判断变量 a = [] 是数组的有：

1. instanceof 不能 ,因为在不同环境下 Array 构造函数不是同一个
2. Arra.isArray(ary)
3. Object.prototype.toString.call(ary)

## '\\\\\\'.replace(new RegExp('\\\\\\\\', 'gi'), '/') 的执行结果是？

/\

## var a = [].push(...[1, 2, 3]),a 的值;

push 返回新的长度 3

## 根据如下代码，set.size 的值为

```javascript
var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN]);
//7个,在set中使用Object.is算法
```

## 错题

```javascript
let obj = {
  count: 100,
  p: () => {
    console.log(this.count);
  },
  q: function () {
    return () => {
      console.log(this.count);
    };
  },
};

obj.p(); //输出为（  undefined ）

obj.q()(); //输出为（100)
```

## new URL()

可以直接将 url 解析为对象

## HTML 字符串转换为 domTree 数据结构

标题：HTML 字符串转换为 domTree 数据结构题目描述：给到 html 字符串`

```
<div id="test" class="myDiv"><div><p id="testP"></p><span></span></div><input type="text"/></div>
实现函数`toDomTree()`最后可以得到如下数据
[
  {
    "label": "div",
    "children": [
      {
        "label": "div",
        "children": [
          {
            "label": "p",
            "children": []
          },
          {
            "label": "span",
            "children": []
          }
        ]
      },
      {
        "label": "input"
      }
    ]
  }
]
```

```javascript
function getDOMTree(html) {
  const root = document.createElement('div');
  root.innerHTML = html;
  const domTree = (father) => {
    const obj = { children: [], label: father.tagName.toLowerCase() };
    for (let ele of father.children) {
      obj.children.push(domTree(ele));
    }
    return obj;
  };
  return domTree(root.children[0]);
}
```

## DOMContentLoaded 和 load 的区别

1. DOMContentLoaded 比 load 更早执行
2. dom 会在所有资源加载结束在执行,包括图片视频
3. 当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无
   需等待样式表、图像和子框架的完全加载

## 选择器权重

1. !important 10000
2. style 1000
3. id 100
4. class 10
5. 属性 1

## [1 < 2 < 3, 3 < 2 < 1]

```javascript
//1<2 true true转换为1,1<3, true
//3<2 false false转换为0 , 0<1 true
[true, true];
```

## ['1', '2', '3'].map(parseInt)

```javascript
// 知识点, parseInt(params,radix)第二个参数是进制,为0默认十进制
所以为[(1, NaN, NaN)];
```

## 数字

```javascript
let a = 3;
a.c; //undefined
```

## 找出有序数组（从小到大排列）中和为 sum 的两个数，要求复杂度为 O(n)，找到一组即可

```javascript
function getSum(ary, sum) {
  const newAry = ary.filter((v) => v < sum),
    length = newAry.length;
  let i = 0,
    j = length - 1;
  while (i < j) {
    if (newAry[i] + newAry[j] === sum) {
      return [newAry[i], newAry[j]];
    } else if (newAry[i] + newAry[j] > sum) {
      j--;
    } else {
      i++;
    }
  }
  return null;
}
```

## 有 n 级台阶，每一步可以走 1 级或 2 级，问一共有多少种走法

```javascript
//斐波那契
/*n=1 只能走一级 一种走法
 *n=2 先走到n=1的位置,再走到2,或者直接走到2,2种方法
 * n   F(n) = F(N-1)+F(N-2)
 */
function NumberOf1(number) {
  // write code here
  var arr = [1, 2];
  for (var i = 2; i < number; i++) {
    arr[i] = arr[i - 1] + arr[i - 2];
  }
  return arr[number - 1];
}
```

## tip

栈保存的对象的引用以及变量,堆中保存的是对象

## 有如下代码

```javascript
var b = 3;
(function () {
  b = 5;
  var b = 2;
})();
console.log(b);

//结果为3
```

## 丑数

```javascript
function getUglyNumber(n) {
  const memo = [1, 2, 3, 4, 5];
  let i = 6;
  while (memo.length < n) {
    let result = Math.min(
      ...[i / 2, i / 3, i / 5].filter((x) => Number.isInteger(x))
    );
    if (memo.includes(result)) {
      memo.push(i);
    }
    i++;
  }
  return memo[n - 1];
}
```

## 求连续二进制

将数字转换为 2 进制求连续的 1

```javascript
function getCount(n) {
  const stack = [];
  while (n > 1) {
    stack.push(n % 2);
    n = Math.floor(n / 2);
  }
  if (n === 1) {
    stack.push(1);
  }
  return stack
    .join('')
    .split('0')
    .sort((a, b) => b.length - a.length)[0].length;
}

function calc(n) {
  let arr = n
    .toString(2) //参数是进制
    .split('0')
    .sort(function (a, b) {
      return b.length - a.length;
    });
  console.log(arr[0].length);
  return arr[0].length;
}
```

## 在 Javascript 中什么情况下会进行装箱/拆箱转换?

1. 装箱 将基本数据类型转换成对应的引用类型
2. 拆箱 将引用类型转换为基本数据类型

## 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

```bash
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```

```javascript
var removeElement = function (nums, val) {
  let i = 0;
  for (let j = 0; j < nums.length; j++) {
    if (nums[j] != val) {
      nums[i] = nums[j];
      i++;
    }
  }
  return i;
};
```

## Math.round(-2019.5)

-2019 四舍五入到更大的数

## 求字符串相乘

```typescript
//有如下规定,输入字符串只有前半截有值
function getProduct(a: string, b: string) {
  let num1 = a.split('0'),
    num1Zero = num1.length - 1,
    num2 = b.split('0'),
    num2Zero = num2.length - 1;
  return (
    Number(num1[0]) * Number(num2[0]) + ''.padStart(num1Zero + num2Zero, '0')
  );
}
```

## 有哪些类型的元素

1. 行内元素 inline <span>
2. 块级元素 block <div>
3. 表格单元 tabel-cell <td>

## 请输入输出结果

```javascript
compute(10, 100);
var compute = function (A, B) {
  console.info(A * B);
};
function compute(A, B) {
  console.info(A + B);
}
function compute(A, B) {
  console.info((A + B) * 2);
}
compute(2, 10);
//220 20
```

**解析**

```javascript
//相当于如下代码
var computed;
function compute(A, B) {
  console.info(A + B);
}
function compute(A, B) {
  console.info((A + B) * 2);
}
compute(10, 100); //220
compute = function (A, B) {
  console.info(A * B);
};
compute(2, 10); // 20
```

## 箭头函数

1. this 指向的是定义时候所在的 context

## JSON.stringify

1. 串行化过程中为 undefined 会被忽略

## 求盒子 wrap 高度

需要注意的是塌陷只会发生在全部为 float 的情况下,如果有其中有一个盒子就会撑开,此
时的高度宽度也包含浮动元素

```html
<style type="text/css">
  .a,
  .b,
  .c {
    box-sizing: border-box;
    border: 1px solid;
  }
  .wrap {
    width: 250px;
  }
  .a {
    width: 100px;
    height: 100px;
    float: left;
  }
  .b {
    width: 100px;
    height: 50px;
    float: left;
  }
  .c {
    width: 100px;
    height: 100px;
    display: inline-block;
  }
</style>

<div class="wrap">
  <div class="a">a</div>
  <div class="b">b</div>
  <div class="c">c</div>
</div>
<!-- 高度为150 -->
```

## 不用 var 声明则为全局变量

```javascript
(function () {
  var a = (b = 5);
})();
//相当于b=5; var a = b;
console.log(b);
console.log(a);
//5  a is not defined
```

## mongoose 创建模型

```JavaScript
const mongoose = require('mongoose');

const TestSchema = new mongoose.Schema({
  createTime: {
    type: String,
    required: true,
  },
});

export const Test = mongoose.model('Test', TestSchema);

async function addTest(data) {
  const test = new Test(data);
  await test.save();
}

async function updateTest(time) {
  const data = await Test.findOneAndUpdate({ createTime: time });
}

async function deleteTest(id) {
  const data = await Test.findByIdAndDelete(id);
}
```

## this 指向

```javascript
//如果没有调用,就是指向的全局
const obj = {
  name: 10,
  sayHi(fn) {
    fn();
  },
};
const fn = function () {
  console.log(this.name);
};
obj.sayHi(fn);
//undefined
const obj = {
  name: 10,
  sayHi(fn) {
    fn();
  },
};
const fn = () => {
  console.log(this.name);
};
obj.sayHi(fn);
// undefined
```

## ast 抽象语法树

### 在 react 中

babel 识别 jsx 语法,转换为 ast 树, jsx 转换 React.createElement 为 ast 所需要的
对象属性

```
{
$$typeof: Symbol(react.element)
key: null
props: {className: "red", children: "Click Me"}
ref: null
type: "div"
_owner: null
_store: {validated: false}
_self: null
_source: null
}

```

### 在 js 中

```JavaScript
function add(a, b) {
    return a + b
}
```

用力拆开，它成了三块：

- 一个 id，就是它的名字，即 add
- 两个 params，就是它的参数，即[a, b]
- 一块 body，也就是大括号内的一堆东西

add 没办法继续拆下去了，它是一个最基础 Identifier（标志）对象，用来作为函数的唯
一标志，就像人的姓名一样。

```
{
    name: 'add'
    type: 'identifier'
    ...
}
```

params 继续拆下去，其实是两个 Identifier 组成的数组。之后也没办法拆下去了。

```
[
    {
        name: 'a'
        type: 'identifier'
        ...
    },
    {
        name: 'b'
        type: 'identifier'
        ...
    }
]
```

## 一元加操作符

```JavaScript
//相当于Number()包裹
console.log(1+ +"2"+"2"); //32 前面必须有空格
```

## 连续赋值

```JavaScript
var a,b;
(function(){
    alert(a);
    alert(b);
    var a=b=3; //var a=3; b=3;声明的b为全局变量
    alert(a);
    alert(b);
})();
alert(a);
alert(b);
```

## 位移运算符

```JavaScript
function a(a)
{
  a^=(1<<4)-1;
   return a;
}
a(10);
//<< 表示左移，先化为2进制，1为01，然后左移4位，成010000，再化为10进制，10000(二进制) = 16(十进制)。 接着a = a ^15 而a = 10，符号^表示异或，也就是比较对应的二进制位是否相同，相同为0，不同为1。 10的二进制 => 1010 15的二进制 => 1111 通过异或运算可以得到 0101 再转换成十进制即是5
```

## 同名变量优先级

形式参数>局部变量(用 var 声明)>全局变量

```JavaScript
var foo = { n: 1 };
(function (foo) {
  console.log(foo.n); //使用的是形式参数
  foo.n = 3; //修改为3
  var foo = { n: 2 };//已经有同名变量,声明无效
  console.log(foo.n);
})(foo);
console.log(foo.n);

```

## 变量回收

全局变量不会被回收

```JavaScript
var i = 1;
var i = 2;
var add = function() {
    var i = 0;
    return function()
{
        i++;
        console.log(i);
    }
}();
add();
//3个
```

## 给网页添加 javascript 的方式有

1. 使用 script 标签，将 javascript 代码写到\<script>\</script>之间

2. 添加外部 javascript 文件

3. 使用行内 javascript 例如 onclick ="javacript:void(0)"

## 整数调用方法

```JavaScript
2.toString()  报错,因为.会被优先解析为小数点

2..toString() '2'
(2).toString() '2'
2 .toString() '2'
```

## typeof null 'object'

## this 指向,类型转化

```JavaScript
'foo' == new function(){ return String('foo'); }; //空对象
'foo' == new function(){ return new String('foo'); }; //this 指向对象,然后返回对象
[] == 0 //类型转换为 true
![] //false
!0 //true
```

## unshift , push 推入值

```JavaScript
var data=[10,20,30];
data.unshift(40,50); // 返回值为长度 [40,50,10,20,30]
data.pop();//30 [40,50,10,20]
data.push(60,70);//返回值为长度 [40,50,10,20,60,70]
data.shift();// 返回值为长度 [50,10,20,60,70]
console.log(data.toString());
```

## var 重复生声明无效

```JavaScript
var carname="Volvo";
var carname;
// carname="Volvo"
```

## Boolean 类型转换

```JavaScript
var x = new Boolean(false); //一个包裹false的对象
if (x) {
  alert('hi');
}
var y = Boolean(0);//false
if (y) {
  alert('hello');
}
```

## 函数声明

js 中只有两种函数声明,一种是匿名函数赋值,一种是 function 声明,

```JavaScript
var f = function g() {
  return 23;
};
typeof g(); //error

```

## repaint(重绘) reflow(回流)

**reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（
实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些
行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、
周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代
码，它们都彼此相互影响着。**

**repaint：**如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或
内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow

下面情况会导致 reflow 发生

**1：改变窗口大小**

**2：改变文字大小**

**3：内容的改变，如用户在输入框中敲字**

**4：激活伪类，如:hover**

**5：操作 class 属性**

**6：脚本操作 DOM**

**7：计算 offsetWidth 和 offsetHeight**

**8：设置 style 属性**

## 异步编程模式

```
回调函数
事件监听
发布/订阅
Promises对象
```

## 如何为 10

```JavaScript
let i = 0;
//数组为空跳过
new Array(10).forEach(() => {
i++;
});


let i = 5;
function a(i) {
i *= 2; //i为形式参数
}
a(i);
```

## 局部变量

```JavaScript
function Foo(){
     var i=0;
     return function(){
         document.write(i++);
       }
}
var f1=Foo(),
f2=Foo();
f1();
f1();
f2();
//010
```

## in 索引值

```JavaScript
1 in [1] //false
```

## 变量提示优先于函数提升

```JavaScript
var a = 10;
function a(){}
console.log(typeof a)
//number
```

## 继承

```JavaScript
var F=function(){};
Object.prototype.a=function(){};
Function.prototype .b=function(){};
var f=new F();
//能取到a,不能取到b
```

## ES5 数组方法跳过空值

## 运算符优先级

```javascript
3 + 2 > 2; // true
```

## 求 x 的值

```JavaScript
var x=0;
   switch(++x)   {
case 0: ++x;
case 1: ++x;
case 2: ++x;
}
 //没有break 3
```

## 求一下表达式哪些为 0

```JavaScript
(()=>{}).length //参数为0
1 & 2 //位于运算同为1才为1
+[] //0
[1,2,-3].reduce((a, b) => a - b, 0)
```
