[地址](https://juejin.im/post/5d87985d6fb9a06add4e6ac3#heading-48)

# HTML

## HTML 语义化有什么好处,HTML5 有哪些新增语义化标签

1.  HTML 语义化的好处是便于后期维护,,能够快速定位所需内容区块,比如导航栏 nav,看到了这个标签就知道这个区域是导航栏区域. 有利于 SEO
2.  nav aside article footer header main

# CSS

## 标准盒模型

1. 分别由 content,padding,border,margin 4 部分组成

## rem 和 em 的区别

1. rem 根据根元素的 font-size 变化,em 根据父元素的 font-size 变化

## CSS 有哪些选择器,CSS 新的特性

1. 标签选择器,类选择器,id 选择器,后代选择器,奇偶选择器:nth-child(odd) even 后代选择器 属性选择器 伪类选择器

2. anima transition border-radius

   ```css
   @keyframs test {
     0% {
       opacity: 0;
     }
     100% {
       opacity: 1;
     }
   }
   a {
     color: red;
     transition: color 1s ease-in;
   }
   a:hover {
     color: blue;
   }
   ```

## 行内元素,块级元素

1. 块级元素单独占一行,如 p,div 等,可以设置宽高
2. 行内元素,不换行,如 span,a 标签等,无法设置宽高,默认高度由内容决定

## 绝对定位于相对定位的区别

1. 绝对定位会根据上一个已经定位的祖先进行定位,
2. 相对定位是相对元素在文档中的初始位置

## Flex 布局的特点有哪些

1. flex 又叫弹性盒布局,会根据 flex 大小来分配宽或者高
2. flex-direction,row 则主轴为横轴,column 则主轴为纵轴
3. jutify-content : center 主轴居中,flex-start 主轴上从最前面开始排列,flex-end 从主轴末尾排列,align-items 则是在纵轴上
4. flex-wrap 默认不换行 nowrap,设置为 wrap 则换行

## BFC 是什么,触发条件

1. 块格式上下文,容器里面的元素不会在布局上影响外面的元素
2. 触发条件,只要满足一个就会触发
3. body 根元素
4. 浮动元素,float 除开 none 以外的属性
5. 绝对定位元素,absolute,fixed
6. display 为 inline-block、table-cells、flex
7. overflow 除了 visible 以外的值

8. 在 css 里面处于同一个 BFC 中,外边距会出现重叠现象,所以我们只要把它放到不同的 BFC 中就能够避免外边距的重叠,例如

   ```html
   blue和red同时有margin:10px;
   在这里给父级元素red-outer设置overflow:hidden,形成BFC所以外边距便不会重叠
   <body>
     <div class="blue"></div>
     <div class="red-outer">
       <div class="red">red inner</div>
     </div>
   </body>
   ```

9. 同时 BFC 也能清除浮动

   ```html
   众所周知,在在这段代码中,由于子元素是浮动的,所以父元素会高度塌陷,只剩下2px的边框高度
   <div style="border: 1px solid #000;">
     <div
       style="width: 100px;height: 100px;background: #eee;float: left;"
     ></div>
   </div>
   加上overflow:hidden让他变为BFC
   <div style="border: 1px solid #000;overflow:hidden;">
     <div
       style="width: 100px;height: 100px;background: #eee;float: left;"
     ></div>
   </div>
   ```

6. BFC能阻止被浮动元素覆盖,在这段代码中,由于左边浮动会形成一个文字环绕的效果,在第二个元素中加入 overflow: hidden,就会变成两列排开

   ```html
   <div style="height: 100px;width: 100px;float: left;background: lightblue">我是一个左浮动的元素</div>
   <div style="width: 200px; height: 200px;background: #eee">我是一个没有设置浮动,
   也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>
   ```

7. 总结所有原因则是,第一个外边距重叠,则是因为 BFC 内部元素不会对外部影响,blue 是 body 的 BFC 内部元素,而 red 则是 red-outer 的内部,两者互不影响所以才会出现这种情况, 第二种因为子元素脱离文档流而造成高度塌陷,形成 BFC 后相当于是个独立的块,所以被撑开, 第三种因为浮动形成文字环绕效果,实际上浮动元素占据了非浮动的一些区域,所以在非浮动块变为 BFC 后,两者排开

## 水平垂直居中

```css
/*flex*/
div {
  display: flex;
  justify-content: 'center';
  align-items: 'center';
}
div {
  margin: 0 auto;
}
```

## Less

```less
//声明变量@开头,混合,嵌套,有作用域,运算
@height: 300px;
.red {
  color: red;
}
div {
  height: @height;
  widht: 10cm+20mm;
  .red();
  .child {
    color: blue;
  }
}
```

# JavaScript

## 基本数据类型

undefined,Object,Number,String,Boolean,Null,Symbol

## 数组操作

```javascript
const ary = [1, 2, 3];
// reduce求和
// join 生成字符串
// push,pop,shift,unshift 末尾推入,末尾取出,顶端取出,顶端推入
// map 生成新的数组
// indexOf 获取满足条件索引
// slice 截断从x到y之前的元素,不包括y
// find 是否存在满足条件的元素,存在则返回true
// findIndex 是否存在满足条件的元素,不存在-1,存在返回索引
// sort 排序,x-y 大于0则x在后面,
// splice (start,count,...elements)
```

## 内置对象

Object, String, Array, Function,Number,Boolean,Symbol 等等,注意是 JavaScript 而不是 DOM 中的内置对象 window

## 什么是闭包

闭包是可以读取其他作用域的变量, **当 B 执行时，如果访问了 A 中变量对象中的值，那么闭包就会产生。** 例如

```javascript
function makeFunc() {
  var name = 'Mozilla';
  function displayName() {
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc(); //myFunc调用的时候能获取到name
```

常理来讲, 在调用 myFunc 的时候由于上面的函数 makeFunc 已经执行完毕,执行上下文都会被释放掉,而其中的变量也不能获取,因为**变量是存储在内存中,简单数据类型存储在栈内存中,复杂数据类型存储在堆中**的,如果没有引用便会被清除,,但是在这里内部的函数作用域使用了外部的变量 name,这个变量便不会被清除,所以形成了闭包.

## 作用域及作用域链

1. 作用域分为全局作用域和局部作用域,全局作用域能在任何地方访问到,而局部作用域只能在当前作用域使用
2. 一般情况下使用变量会到当前的作用域取值,如果没有则会到上一个栈中的执行上下文查找,直到查询到栈底,也就是全局作用域.这个就是作用域链

## 原型和原型链

1. 每个对象都会初始化一个属性 prototype 指向他的原型,当访问这个对象的一个属性时,如果不存在便会在他的原型上查找,如果还不存在则会继续前往原型的原型查找,这就是原型链

## 图片懒加载

1. 获取屏幕的高度,在用户未查看到剩余部分的时候,将剩余部分的 img 标签 src 属性保存在 data-src 中,当滑动到可以查看到的区域时候,在将 src 属性设置为图片的地址

## 异步回调地狱

1. promise,async/await

## 解释 this

1. this 指向当前的调用者

# vue

## vue 生命周期有哪些,解释下他呢,什么时候渲染好 DOM 呢

1. 有

   1. beforeCreate
   2. created
   3. beforeMounte
   4. mounted
   5. beforeUpdate
   6. updated
   7. beforeDestroy
   8. destroyed

2. 创建,挂载,销毁,更新,这些钩子会在 vue 在这个过程被调用
3. mounted

## v-show 和 v-if 的区别

1. v-show 只是改变 DOM 的 display
2. v-if 会直接把 DOM 注释掉,再次使用则需要重新渲染

## 开发中常用的指令

1. v-show,v-if,v-for,v-model,v-on,v-bind,v-html

## 组件之间传值

1. 父传子 通过 props 传值 子组件中 props 定义参数,然后在父组件中用 v-bind 传递参数

2. 子传父,子组件中使用\$emit(eventName,props)触发事件,并传递参数,并在父组件中使用@eventName 监听事件,

3. 兄弟之间传值

   ```vue
   //Bus.vue
   <script>
   import Vue from 'vue';
   export default new Vue();
   </script>

   //test1.vue
   <template>
     <button @click="toBus">子组件传给兄弟组件</button>
   </template>

   <script>
   import Bus from '../common/js/bus.js';
   export default {
     methods: {
       toBus() {
         Bus.$emit('on', '来自兄弟组件');
       },
     },
   };
   </script>

   //test2.vue
   <script>
   import Bus from '../common/js/bus.js';
   export default {
     mounted() {
       Bus.$on('on', (data) => {
         console.log(data);
       });
     },
   };
   </script>
   ```

## 绑定 class 的数组语法

1. :class="['e','a']"

## 路由跳转方法

1. 命令式,this.\$router.push(routerPath) 如/home
2. 声明式 <router -link to='routerName'></router -link> 如 home

## MVVM

1. 数据驱动视图改变,Model View, ViewModel,分别代表数据模型,ui 组件,监听模型数据改变

## computed 与 watch 什么区别

1. computed 是计算属性,例如后端给你的数据是个整数,你需要进行一次处理,来使其带上两位小数,这就是计算属性,计算属性中使用的数据如果改变,那么 computed 也会重新计算,具有缓存性质,只有依赖的 data 改变才会重新计算
2. watch 是监听数据,当数据改变的时候触发回调

## key

1. 在组件循环生成的后,如果有数据改变,vue 会对 key 值相同的跳过渲染,对 key 值不同的重新渲染,而达到优化性能的目的

## 组件中的 data 为什么是函数

1. 假设组价中的 data 是一个对象,那么由于对象赋值是引用的地址,所以在组件复用的时候,复用的组件的 data 都是同一个 data,其中一个 data 改变了,其他所有的 data 都会改变
2. 而是一个函数,每次调用的时候都会返回一个不同的对象,这种函数也叫工厂函数

## class 与 style 动态绑定

1. :class='' :style=''

## vue 的单项数据流

1. props 传参

## keep-alive

1. 在组件切换的时候,组件会销毁,而加上 keep-alive 的时候组件在切换后便不会被销毁

## v-model 原理

1. 在 input 上调用@change 获取改变后的值,并更新 data 中的 value 属性,并将 input 的 value 动态绑定为 data 中的 value 属性

## nextTick

1. dom 更新是一个异步操作,更新后马上调用回调

## vue 插槽

1. \<slot>\</slot> 在一个组件大部分都相同的情况下,自定义其中的一小部分

   ```vue
   <main>
     <slot name="test"></slot>
   </main>
   <main>
     <template v-slot:test> #test 简写写法
       <p>123</p>
     </template>
   </main>
   ```

## vue-router 有哪几种导航钩子

1. 前置守望钩子 router.beforeEach(to,from,next)
2. 后置守望钩子 router.afterEach(to,from,next)

## vuex

1. 状态管理工具,把经常使用到的状态放在中间,从而不用使用重复传值的情况
2. 有 mapState,mapMutation,mapAction 来将 vuex 中的 state,mutation,action 映射到 vue 中

## 你对 vue 项目有哪些优化

1.  多复用组件
2.  路由懒加载
3.  图片懒加载
4.  减少代表 babel 编译为 ES5 的代码冗余

# ES6

## var let const 的区别

1. var 有变量提升,能够重新赋值,没有块作用域
2. let,和 const 没有生命提前,有暂时性死区,声明的变量有块作用域
3. let 和 const 的区别是,let 声明的变量可以重新赋值,而 const 不能

## 解构赋值

```javascript
//对象解构赋值
const { a, b, c } = { a: 1, b: 2, c: 3 };
const { a: d, b, c } = { a: 1, b: 2, c: 3 };
//数组解构辅助
const [a, b, c] = [31, 22];
```

## forEach,for in , for of 三者区别

1. forEach 数组的方法能够枚举出 value
2. for in 枚举出 key 值
3. for of 实际上调用的当前的迭代器方法 Symbol.iterator

## 使用箭头函数应该注意什么

1. 本身没有 this,this 指向到父级
2. 不能用作构造函数

## set 和 map 的区别

1. set 相当于一个没有重复值的数组集合
2. map 相当于 key 值能为任意值的对象
3. 都使用同值相等算法

## 简单描述下 promise,并手写一个 promise 实例

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('complete');
  }, 0);
});
promise.then((msg) => {
  console.log(msg);
});
```

# AJAX

## 如何创建一个 ajax 请求

```JavaScript
//原声ajax
const xhr = new XMLHttpRequest();
xhr.open('GET',url);
xhr.send(null);
xhr.onReadyStateChange=()=>{
  if(xhr.status===200&&xhr.readyState===4){
    console.log(xhr.response);
  };
};
```

## 同步和异步的区别

因为 JavaScript 是一个单线程语言,所以代码从上往下依次执行这就是同步,但碰到耗时的操作,比如 I/O 操作或者网络请求,就会卡顿页面,造成阻塞,而异步操作会在 js 执行到这里的时候单开一个线程执行异步请求,而主线程继续执行其他剩余代码,等待异步事件执行完成进入**事件队列**,然后执行回调返回结果

## get 和 post 的区别

实际区别并不大,get 能做到的 post 也能做到,但是根据 RESTful 风格,get 一般用来查询请求,post 一般用来增加操作,get 是幂等,post 是非幂等

## 如何解决跨域问题

跨域是浏览器同源策略,服务器和前端资源需要在同一个 ip,端口,协议才不会发生跨域

1. nginx 反向代理,通过 nginx 将后端服务器代理到与前台域名端口相同的地址
2. 后端设置跨域请求头 Access-control-allow-origin 为\*

## 什么是 json

是一种轻量级的数据类型可以和 JavaScript 的对象进行互相转换,JSON.parse 将 json 转换为 js 对象,JSON.stringify 将 js 对象转换为 json 字符串

# git

```bash
git init # 初始化本地git仓库
git remote add localname gitUrl #关联远程git仓库
git remote # 查看当前关联的仓库

git add . #将更改文件保存到暂存区
git commit -m msessge # 提交信息
git push xx # 推送到xx分支,不填写默认推送到当前分支
git pull # 拉取远端资源
git status # 查看当前状态
git clone #拉取远程仓库
```

# 网络协议

## 网络分层

1. 应用层
2. 表现层
3. 会话层
4. 传输层
5. 网络层
6. 数据链路层
7. 物理层

## HTTP/HTTPS

1. HTTP 全名超文本传输协议,能够传输资源
2. HTTPS 是有 ssl 协议加密的 http,能够大大提高安全性

## HTTP 状态码

```
2xx 成功 200成功
3xx 重定向 301 永久重定向 302临时重定向 304击中缓存
4xx 客户端错误 404未找到资源 403拒绝访问
5xx 服务器错误 504请求超时 500服务器错误
```
