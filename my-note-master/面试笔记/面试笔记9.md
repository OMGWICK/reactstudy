## react生命周期

1. componentDidUpdate
2. componentDidMount
3. componentWillUnmount

## 网路请求应该放在react那个生命周期中

1. componentDidMount 
2. useEffect(()=>{},[])

## setState是同步还是异步

有时候表现出同步,有时候表现出异步

1. 在合成事件中表现为异步,也就是例如onClick中调用setState表现为异步,
2. 直接在componentDidMount中调用和其setTimeout方法中调用都是同步

## React组件通信如何实现

1. 父传子  绑定子的props
2. 子传父  将回调传入子中,子调用
3. 全局管理 redux

## react有哪些优化性能手段

1. 更多的使用无状态组件

## react如何进行组件/逻辑复用

1. 抽离共通逻辑为hook
2. 可复用组件抽离为单个文件

## hoc,render props hook的优劣

1. hoc是高阶组件,传递参数为组件,然后返回另一个组件,比较常见的是redux 的connect

   ```react
   //我理解的常用场景是,抽离共通的数据,然后通过hoc导入
   function withMouse(Component) {
     return class extends React.Component {
       render() {
         return (
           <Mouse render={mouse => (
             <Component {...this.props} mouse={mouse} />
           )}/>
         );
       }
     }
   ```

   

2. render props

   ```react
   class Test extends React.Component{
     constructor(props){
       super(props);
       this.state = {
         x:1
       }
     }
     render(){
       return <div>{this.props.render(this.state.x)}</div>
     }
   }
   
   class App extends React.Component{
     render(){
       return <div>
         <Test render={(x)=><Hello x={x} />}></Test>
       </div>
     }
   }
   ```

   

## redux的流程

1. dispatch action到reducer中,
2. reducer进行比对,比对后修改

## react-redux如何工作

```react
import {connect} from 'react-redux'

function App(){
  return <div></div>
}

const stateToProps =(state)=>({
  isLogin:state.isLogin
})

const dispatchToProps=(dispatch)=>({
  changeLoginStatus(data){
    const action = {
      type:I_AM_LOGIN,
      data
    };
    dispatch(action);
  }
})

export default connect(stateToProps,dispatchToProps)(App)
```

## redux如何进行异步操作

```JavaScript
//redux-thunk
//store index.js配置
import {createStore,applyMiddleware} from 'redux'
import reducer from './reducer'
import thunk from 'redux-thunk'

export const store = createStore(reducer,applyMiddleware(thunk))
//使用
export const changeText = () =>{
  return (dispatch)=>{
    axios.get().then((res)=>{
      const action ={
        type:MY_TEXT,
        data:res.data
      }
      dispatch(action);
    })
  }
}
```

[链接](https://juejin.im/post/5dc20a4ff265da4d4e30040b)

## 类组件和函数式组件的区别

1. 类组件
2. 函数式组件开发效率更高,性能更高

## react中的ref如何创建,有什么用

1. hook useRef

2. React.createRef

3. 或者

   ```react
   class UserForm extends Component {
     handleSubmit = () => {
       console.log("Input Value is: ", this.input.value)
     }
     render () {
       return (
         <form onSubmit={this.handleSubmit}>
           <input
             type='text'
             ref={(input) => this.input = input} /> // Access DOM input in handle submit
           <button type='submit'>Submit</button>
         </form>
       )
     }
   }
   ```

   

4. 取到该节点的dom

## react中如何处理事件

1. 为了解决浏览器的兼容性问题,实际上在react中的事件监听会经过一次处理

## state与props的区别是什么

1. state是当前组件的状态可以通过ssetState修改
2. props是当前组件的参数,是其他组件传递过来的,不可变

## 什么是高阶组件,有什么用

1. 高阶组件是HOC是一个函数接受一个参数为组件的返回一个组件
2. 可以抽离共通的逻辑代码,然后注入组件

## 在构造函数中调用super的作用什么

1. 构建当前类的this
2. 继承React.Component的属性和方法

## 什么是受控组件

1. 在HTML中,表单元素如input,textarea,select之类的元素,通常是自己维护state,并根据用户输入来更新,而在react中,通过state绑定,和事件监听,使react成为唯一数据源,这种元素被称为受控组件

## 讲讲React.createElement

1. jsx实际上会转换为React.createElement

   ```react
   const element =<div className="hello">123</div>;
   
   const element = React.createElement('div',{className:'hello'},'123')
   ```

   

## 讲讲jsx

1. jsx 也是all in js 的一种体现
2. 将html代码直接在js文件中写入,然后通过babel转义为react.createElement

## 根据下面定义的代码，可以找出存在的两个问题吗 ？

```react
class MyComponent extends React.Component {
  constructor(props) {
    this.state = { clicks: 0 };
  }
  componentDidMount() {
    this.refs.myComponentDiv.addEventListener('click', this.clickHandler);
  }
  componentwillUnmount() {
    this.refs.myComponentDiv.removeEventListener('click', this.clickHandler);
  }
  clickHandler() {
    this.setState({ clicks: this.clicks + 1 });
  }
  render() {
    let children = this.props.children;
    return (
      <div className="my-component" ref="myComponentDiv">
        <h2>My Component ({this.state.clicks} clicks})</h2>
        <h3>{this.props.headerText}</h3>
        {children}
      </div>
    );
  }
}
```

1. 构造函数中未调用super
2. 未创建ref
3. 事件监听器未绑定当前作用域

## react 的strictmod 是什么

1. 严格模式,用React.StrictMod包裹App组件

## 为什么类方法需要绑定到类实例

1. 在类组件中,当把事件处理函数作为回调传递过去后,会丢失绑定的this

```react
<button type="button" onClick={this.handleClick}>Click Me</button>

```

## 描述下mvc

1. mvc是model,view,controllers
2. model数据修改通过控制器,然后更改view

## 受控组件非受控组件区别

## 什么是Reac context

1. React.createContext

2. 分发数据给子组件

   ```react
   function App(){
     const MyContext = React.createContext(1);
   	const [data,setData] = useState(1);
   	return <MyContext.Provider value={data}>
            <Child />
   		  </MyContext.Provider>
   }
   //
   function Child(){
     const data = useContext()
     return <div>{data}</div>
   }
   class Child extends React.Component{
     render(){
       return <MyContext.Consumer>
          {value => /* 基于 context 值进行渲染*/}
        </MyContext.Consumer>
     }
   }
   ```

## 什么是纯函数

只依赖参数,不依赖于外部值 的函数,传入相同参数永远返回相同的值

## 如何避免组件的重新渲染？

1. React.memo接受一个函数式组件返回另一个函数式组件