[链接](https://www.nowcoder.com/tutorial/96/4700c6f1f3334c9191a38406002efa65)

# HTML/HTTP/浏览器(1)

## TCP和UDP的区别

1. TCP是面向连接的,UDP是无连接的即发送数据前不需要建立链接
2. TCP提供可靠的服务,通过TCP连接传送的数据,无差错,不丢失,不重复,UDP不保证可靠交付
3. TCP面向字节流,UDP面向报文,并且网络出现拥塞不会降低发送速率,所以会出现丢包
4. TCP只能1对1,UDP可以1对多
5. TCP头部20字节,UDP8字节
6. TCP可靠传输,UDP不可靠

## 几个很实用的BOM属性对象方法?

1. location
2. history
3. navigator

## 400和401、403状态码

1. 400请求无效
2. 401 请求需要用户验证
3. 403 拒绝访问

## Cookie、sessionStorage、localStorage的区别

+ 共同点
  1. 都是保存在浏览器端的
  2. 都有跨域限制

+ 不同点
  1. 大小不同,cookie最大4kb,sessionStorage,localStorage最大5mb
  2. api不同,cookie在浏览器端通过document.cookie获取,而localStorage,sessionStorage通过getItem获取
  3. 在发送请求的时候cookie总会被携带

##  说一下web worker

脚本执行的时候页面不会渲染,而web worker会新开一个线程执行js

## 对HTML语义化的理解

1. 增强SEO
2. 降低后期维护成本

## cookie如何防止XSS攻击

1. 设置httponly,禁止js控制脚本访问cookie
2. 设置secure 只能通过https访问

## cookie和session的区别

1. http是无状态协议,所以cookie一般用来存储session信息

## 讲讲viewport和移动端布局

1. 可以设置vw,基于视口布局,移动端可自适应

## addEventListener参数

document.addEventListener(eventName,callback,capture)

# HTML/HTTP/浏览器(2)

## 说说状态码大概的分类并列举几个

1. 2xx ok
2. 3xx 重定向
3. 4xx 客户端错误
4. 5xx 服务端错误

``` 
200 成功 301永久重定向 302临时重定向 304击中缓存 404 未找到资源 403拒绝访问 400 客户端错误 500服务端内部错误 502服务端超时
```

## 强,协商缓存

1. 状态码200,强缓存是不通过请求,直接从浏览器端加载资源常见的控制头有cache-control,expires,后者优先级更高
2. 状态码304,协商缓存是带上请求头,然后服务端对比,未过期则加载浏览器返回304击中缓存,过期则请求,常见头部有last-modify,e-tag

## 前端优化

1. 尽可能打包成单个文件
2. 图片使用懒加载
3. 静态资源放在不同的域名服务器下,同域名限制2-10个TCP/IP请求
4. 设置协商缓存
5. CDN分发

## GET,POST的区别

1. GET产生一个TCP数据包,POST会产生两个数据包,
2. POST能够携带的数据更多
3. POST更安全

## 301和302的区别

1. 301永久重定向
2. 302临时重定向

## 如何画一个三角形

```css
div{
  width:0;
  height:0;
  border:20px transparent solid;
  border-bottom:20px red solid;
}
```

## 讲讲状态码304和200

1. 304是浏览器端发送请求头部时间未过期,服务端返回304,然后浏览器端从缓存中加载资源
2. 200是请求资源成功

## HTML5新增的元素

```
article footer header nav aside main section
```

## 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？

1. dns寻址,通过dns查询到ip
2. 然后经历TCP/IP连接经历三次握手
3. 发送资源到浏览器端,浏览器接受资源
4. 浏览器端解析DOM,建立DOM Tree,解析CSS建立 css规则树,然后合成为 Render Tree,进行渲染
5. 当加载到JS资源,则会先下载js并执行,同时停止HTML渲染
6. 然后开始从上到下执行js代码

## cookie和session的区别，localstorage和sessionstorage的区别

1. http是无状态的,因此需要用session记录状态,而cookie是用来保存session的
2. api相同,也有同源限制,但是sessionStorage在关闭窗口后便会消失,而localStorage会一直留存

## 常见的HTTP的头部

1. connection 连接形式 值一般为keep-alive
2. content-type 资源类型

## 浏览器在生成页面的时候，会生成那两颗树？

1. DOM树
2. CSS规则树

## CSRF和xss网络攻击防范

1. csrf是攻击者盗用用户的身份,以用户的名义发送恶意请求
2. xss是跨站脚本攻击,注入恶意脚本,在用户浏览网页的时候进行攻击,例如获取cookie,一般设置为httponly可解决

# CSS(1)

## 画一条0.5px的线

```css
div{
  border-bottom:1px solid black;
  transform:scale(0.5)
}
```

## link标签和@import标签的区别

1. link属于html标签,@import是css提供的
2. 页面加载时,link会被同时加载,而@import引用的css会瞪大页面加载完成后加载
3. link权重高于@import

## transition和animation的区别

1. transition:all 1s ease-in  transition是过度
2. animation需要定义关键帧,实现动画

## Flex布局

1. 使用display:flex便能使用
2. justify-content主轴方向调整,为center则居中
3. align-items垂直于主轴方向调整,为center则垂直居中
4. flex-direction 调整主轴方向,column为垂直轴,row为水平轴
5. flex-wrap 是否换行默认不换行 wrap则换行

## BFC

满足如下任意一个条件构成BFC

1. 根元素
2. float不为none
3. position为绝对定位的fixed absolute
4. display为tabel-cell inline-block,flex
5. overflow 不为visible

## 垂直居中的方法

```css
div{
  display:flex;
  align-items:center
}
```

## 关于js动画和css3动画的差异性

1. js动画更加美观
2. css动画兼容性更好

## 说一下块元素和行元素

1. 块元素会换行
2. 行元素不换行,不能设置宽高和上下外边距

## 多行元素的文本省略号

```css
div{
  overflow:hidden;
  text-overflow:ellipsis;
  white-space: nowrap;
}
```

##  visibility=hidden, opacity=0，display:none

1. visibility=hidden隐藏,但是仍然在文档流中
2. opacity 只是元素的可见度为0,视觉上不能看见
3. 从文档流中消失

## 浮动清除

1. 父级套一个overflow:hidden形成BFC
2. 子级创建一个DOM设置clear:both

##  CSS选择器有哪些，优先级呢

1. !important 10000
2. style 1000
3. id 100
4. class 10
5. 属性 1

## 介绍一下盒模型

分为两种,可通过box-sizing设置

1. content-box 标准盒子模型 宽为content
2. border-box 怪异盒子模型 宽为content+padding+border

## 三栏布局

```html
<html lang="en">
  <head>
    <style>
      #fa {
        width: 100%;
        height: 50px;
      }
      #c1 {
        background-color: red;
        float: left;
        width: 50px;
        height: 50px;
      }
      #c2 {
        background-color: blue;
        width: 100%;
        height: 50px;
      }
      #c3 {
        background-color: aqua;
        height: 50px;
        float: right;
        width: 50px;
      }
    </style>
  </head>
  <body>
    <div id="fa">
      <div id="c1"></div>
      <div id="c3"></div>
      <div id="c2"></div>
    </div>
  </body>
</html>
```

# JavaScript(1)

## get和post在缓存方面的区别

1. 因为get请求是幂等的,而post是不幂等的,所以一般get请求会被缓存

## 说一下闭包

1. 使用外部作用域的变量

##  说一下类的创建和继承(分别用ES5和ES6实现)

1. ES5

   ```JavaScript
   function Animal(name){
     this.name = name
   }
   function Cat(name,age){
     Animal.call(this,name);
     this.age = age;
   }
   Cat.prototype = new Animal();
   
   ```

2. ES6

   ```javascript
   class Animal{
     constructor(name){
       this.name = name
     }
   }
   class Cat extends Animal{
     construtor(name,age){
       super(name);
       this.age = age;
     }
   }
   ```

## 有如下代码,如何解决异步回调地狱

```JavaScript
fs.readFile(url,(err,a)=>{
  fs.readFile(a,(err,b)=>{
    fs.readFild(b,(err,data)=>{
      console.log(data)
    })
  })
})
//async/await
async function getData(url){
  const a = await fs.readFile(url);
  const b = await fs.readFile(a);
  const data = await fs.readFild(b)
  return data;
}
```

## 说说前端中的事件流动

现代浏览器默认事件监听会在冒泡阶段调用程序

1. 捕获
2. 目标
3. 冒泡

## 说一下图片的懒加载和预加载

1. 懒加载,将图片的真实地址放在data-src中,当浏览到这个地方的时候再将src替换为data-src的数据
2.   预加载 提前加载图片，当用户需要查看时可直接从本地缓存中渲染 

## mouseover和mouseenter的区别

1. mouseover 鼠标移入,包括子元素
2. mouseenter鼠标移入,不包括子元素

##  js的new操作符做了哪些事情

```JavaScript
function myNew(constructor,...params){
  const obj = {};
  constructor.call(obj,...params);
  Object.setPrototypeOf(obj,constructor.prototype);
  return obj
}
```

## 改变函数内部this指针的指向函数（bind，apply，call的区别）

1. bind 第一个参数是this指向,剩余参数是需要传递的参数,生成一个this指向目标参数的函数,
2. apply,第一个参数是改变的目标,第二个是参数数组,需要给函数传递的数组,然后调用
3. 和appy只有一点不同,那就是可以传递很多个参数

##  js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？

clientHeight：表示的是可视区域的高度，不包含border和滚动条

offsetHeight：表示可视区域的高度，包含了border和滚动条

scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。

clientTop：表示边框border的厚度，在未指定的情况下一般为0

scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高

## 异步加载js的方法

1. defer,异步下载,当DOM解析完毕后执行
2. async,异步下载,下载完成立即执行

##  js的节流和防抖

```JavaScript
//防抖,在经过一定的时间延迟后时间才会执行
const debounceFactory =(delay)=>{
  let timer = null;
  return (callback) => {
    clearTimeout(timer);
    timer = setTimeout(callback,delay)
  }
}
//节流,一段时间内只能执行一次
const throttleFactory = (delay)=>{
  let pre = Date.now();
  return (callback) => {
    const now = Date.now();
    if(now-pre>delay){
      pre = now;
      callback()
    }
  }
}
```

## 对象深度克隆的简单实现

```JavaScript
function clone(data){
  const type = typeof data,obj = {};
  if(type !== 'object'){
    return data;
  }
  for(let k in data){
    obj[k] = clone(data[k]);
  };
  return obj;
}
```

## 将原生的ajax封装成promise

```javascript
function myFetch(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('get', url);
    xhr.send(null);
    xhr.onreadystatechange = () => {
      //注意的是,状态码为200,数据不一定传输完成
      if (xhr.status === 200 && xhr.readyState === 4) {
        resolve(xhr.responseText);
      } else if (xhr.readyState === 4) {
        reject();
      }
    };
  });
}

```

##  js监听对象属性的改变

1. ES5

   ```javascript
   const obj = {a:1}
   Object.defineProperty(obj,'a',{
     set(value){
       return Reflect.set(obj,'$a',value)
     }
   })
   
   ```

2. ES6

   ```javascript
   const obj = {a:1}
   new Proxy(obj, {
     set(target, p, value) {
       return Reflect.set(target, p, value);
     },
   });
   ```

   

## 如何实现一个私有变量，用getName方法可以访问，不能直接访问

```javascript
function factory(){
  const name = 'zhangfei';
  const getName = () => {
    return name;
  }
  return getName;
}
```

##  ==和===、以及Object.is的区别

1. == 相比较会进行类型转换,复杂类型会向简单类型转换
2. === 不会进行转换
3. Object.is 是同值相等的实现, NaN和自身相等

## setTimeout、setInterval之间的区别

1. 延时多少秒执行,是异步操作
2. 每隔多少秒就执行一次

## 自己实现一个bind函数

```JavaScript
function myBind(fn, obj, ...params) {
  return function () {
    obj.fn = fn;
    Object.setPrototypeOf(obj, new fn());
    obj.fn(...params);
    delete obj.fn;
  };
}
```

## 用setTimeout来实现setInterval

```javascript
function myInterval(callback, delay) {
  setTimeout(() => {
    callback();
    myInterval(callback, delay);
  }, delay);
}
```

## 求解如下代码输出顺序

```JavaScript
setTimeout(function () {
  console.log(1);
}, 0);
new Promise(function (resolve, reject) {
  console.log(2);
  resolve();
})
  .then(function () {
    console.log(3);
  })
  .then(function () {
    console.log(4);
  });
//微任务
process.nextTick(function () {
  console.log(5);
});
console.log(6);
//2 6 5 3 4 1

```

## 简单的实现一个promise

```JavaScript
function myPromise(constructor) {
  let self = this;
  self.status = 'pending'; //定义状态改变前的初始状态
  self.value = undefined; //定义状态为resolved的时候的状态
  self.reason = undefined; //定义状态为rejected的时候的状态
  function resolve(value) {
    //两个==="pending"，保证了状态的改变是不可逆的
    if (self.status === 'pending') {
      self.value = value;
      self.status = 'resolved';
    }
  }
  function reject(reason) {
    //两个==="pending"，保证了状态的改变是不可逆的
    if (self.status === 'pending') {
      self.reason = reason;
      self.status = 'rejected';
    }
  }
  //捕获构造异常
  try {
    constructor(resolve, reject);
  } catch (e) {
    reject(e);
  }
}

```



## 简单实现Node的Events模块

```JavaScript
class EeventEmitter {
  constructor() {
    this.interval = null;
  }
  on(eventname, callback) {
    this.interval = setInterval(() => {
      if (this.eventname === eventname) {
        callback();
      }
    }, 100);
  }
  emit(eventname) {
    clearInterval(this.interval);
    this.eventname = eventname;
  }
}
```

# javascript(2)

## js判断类型

```javascript
typeof 
Object.prototype.toString.call()
instanceof
```

##  数组去重

```javascript
const a = [1,1,1,2,2,3,4,5,5,6]
//对象去重法
function foo(ary){
  const obj = {};
  for(let k in ary){
    obj[ary[k]] = true;
  };
  return Object.keys(obj);
}
//new set去重法
function foo(ary){
  return [...new Set(ary)]
}
```

## 去除字符串首尾空格

str.trim()

##  JS实现跨域

1. 服务端设置access-control-allow-origin为*
2. jsonp跨域
3. nginx反向代理

## Js基本数据类型

1. number
2. string
3. boolean
4. undefined
5. null
6. symbol

## null == undefined为什么相等

规范中提到， **要比较相等性之前，不能将 null 和 undefined 转换成其他任何值**，并且规定null 和 undefined 是相等的。

##  编写代码，

```bash
满足以下条件： 
（1）Hero("37er");执行结果为 Hi! This is 37er 
（2）Hero("37er").kill(1).recover(30);执行结果为 Hi! This is 37er Kill 1 bug Recover 30 bloods 
（3）Hero("37er").sleep(10).kill(2)执行结果为 Hi! This is 37er //等待10s后 Kill 2 bugs //注意为bugs （双斜线后的为提示信息，不需要打印）
```

```JavaScript
function Hero(str) {
  const obj = {};
  let time = 0;
  console.log(`hi!,this is ${str}`);
  obj.kill = function (count) {
    setTimeout(() => {
      console.log(`kill ${count} bug`);
    }, time * 1000);
    return obj;
  };
  obj.sleep = function (delay) {
    time = delay;
    return obj;
  };
  obj.recover = function (count) {
    console.log(`bug Recover ${count} bloods `);
    return obj;
  };
  return obj;
}
```

# javascript(3)

## vue的生命周期

1. beforeCreated
2. created
3. beforeMount
4. mounted
5. beforeUpdate
6. updated
7. beforeDestroy
8. destroyed

## 简单介绍一下symbol

1. 通过Symbol函数创建
2. Symbol(1)===Symbol(1) false
3. Symbol.for(1) === Symbol.for(1) true
4. Symbol.keyFor(Symbol.for(1))  获取for登记 的key,注意只能获取for登记的值

## 介绍一下promise,并实现一个简单的promise

1. 是一个容器存储着未来会发生的事件
2. 有三个状态,pending,rejected ,fulfilled,且只会只会同时存在一种状态
3. 微任务

```JavaScript
class MyPromise {
  constructor(callback) {
    this.status = 'pending';
    this.data = '';
    this.resolve = this.resolve.bind(this);
    this.reject = this.reject.bind(this);
    callback(this.resolve, this.reject);
  }
  resolve(data) {
    if (this.status === 'pending') {
      this.status = 'fulfilled';
      this.data = data;
    }
  }
  reject(data) {
    if (this.status === 'pending') {
      this.status = 'rejected';
      this.data = data;
    }
  }
  then(callback) {
    const that = this;
    if (this.status === 'fulfilled') {
      setTimeout(() => {
        callback(that.data);
      }, 0);
    }
    return that;
  }
  catch(callback) {
    const that = this;
    if (this.status === 'rejected') {
      setTimeout(() => {
        callback(that.data);
      }, 0);
    }
    return that;
  }
}
```

##  js原型链，原型链的顶端是什么？Object的原型是什么？Object的原型的原型是什么？在数组原型链上实现删除数组重复数据的方法

1.  顶端是null

2. 对象

3. null

4. 删除重复数据

   ```JavaScript
   Array.prototype.delete = function(){
     return [...new Set(this)]
   }
   ```

## 写个函数，可以转化下划线命名到驼峰命名

```javascript
function convert(str){
  return str.split('_').map((v,index)=>{
    if(index>0){
      return v.slice(0,1).toUpperCase()+v.slice(1)
    }
    return v
  }).join('')
}
```

## 深浅拷贝的区别和实现

js中复杂数据类型的声明是引用,变量实际上是指向的内存地址的指针,浅拷贝只是复制了指针,指向的同一个对象,而深拷贝是完全复制

## JS中string的startWith和indexOf两种方法的区别

1. startsWith 判断字符串是否以xx开头
2. indexOf判断字符串是否包含xx,如果包含返回索引

## js字符串转数字的方法

parseFloat,parseInt

## JS的基本数据类型有哪些，基本数据类型和引用数据类型的区别，NaN是什么的缩写，JS的作用域类型，undefined==null返回的结果是什么，undefined与null的区别在哪，写一个函数判断变量类型

1. undefined,null,boolean,string,number,symbol

2. 引用数据类型放在堆内存,基本数据类型放在栈内存

3. not a number

4. 块作用域

5. true

6. undefined 声明未赋值,null是值为空

7. 如

   ```JavaScript
   function getType(param) {
     return Object.prototype.toString.call(param).slice(8, -1);
   }
   ```

   

## setTimeout(fn,100);100毫秒是如何权衡的

1. 100ms不等于实际上执行所需时间
2. 实际执行所需时间为 100ms+进入事件队列时间

## 写一个newBind函数，完成bind的功能。

```JavaScript
function myBind(fn, obj, ...params) {
  return function () {
    obj.fn = fn;
    Object.setPrototypeOf(obj, new fn());
    obj.fn(...params);
    delete obj.fn;
  };
}
```

