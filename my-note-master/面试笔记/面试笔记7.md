##  [前端需要注意哪些 SEO](https://github.com/qiu-deqing/FE-interview#前端需要注意哪些seo) 

1. 合理的title,description,keywords,搜索引擎对三项的权重不断减小
2. 非装饰性图片 必须加上alt
3. 重要内容不要用js输出
4. 语义化HTML

##   img的title和alt有什么区别  

1. title是全局属性,当鼠标滑动到图片上的时候显示
2. alt是img的特有属性,一般用于图片无法显示,除了装饰性图片都必须设置的有意义的值,因为搜索引擎会重点抓取

##  [doctype 是什么,举例常见 doctype 及特点](https://github.com/qiu-deqing/FE-interview#doctype是什么举例常见doctype及特点) 

1. doctype声明当前html版本

##  [HTML 全局属性(global attribute)有哪些](https://github.com/qiu-deqing/FE-interview#html全局属性global-attribute有哪些) 

1. title
2. class
3. id
4. style
5. data-* 自定义属性
6. hidden

##  [什么是 web 语义化,有什么好处](https://github.com/qiu-deqing/FE-interview#什么是web语义化有什么好处) 

1. 使用语义化的html标签,有aside,article,header,footer,main
2. 优化seo,后期维护更加方便

##  [HTTP method](https://github.com/qiu-deqing/FE-interview#http-method) 

1. get
2. post
3. put
4. delete

##  [从浏览器地址栏输入 url 到显示页面的步骤(以 HTTP 为例)](https://github.com/qiu-deqing/FE-interview#从浏览器地址栏输入url到显示页面的步骤以http为例) 

1. dns寻址
2. TCP三次握手
3. 建立连接
4. 传输数据

##  [HTTP request 报文结构是怎样的](https://github.com/qiu-deqing/FE-interview#http-request报文结构是怎样的) 

1. 第一行 请求方法 请求url http版本

##  [如何进行网站性能优化](https://github.com/qiu-deqing/FE-interview#如何进行网站性能优化) 

1. webpack打包的时候尽量打包到高版本js,减少冗余代码
2. 因为浏览器限制每个域名同时只能并发2-10个tcp连接,所以讲其他的静态资源,例如图片放到不同的域名下
3. 在网页有很长的内容时,下方看不到的图片使用懒加载

##  [HTTP 状态码及其含义](https://github.com/qiu-deqing/FE-interview#http状态码及其含义) 

1. 200 成功
2. 301 304 重定向
3. 404 未找到资源
4. 502 超时

## 原始类型有哪几种？null 是对象吗？原始数据类型和复杂数据类型存储有什么区别？

1. null,undefined,boolean,number,string,symbol
2. typeof 判定是对象,但在tc39的标准中不属于对象
3.  原始数据类型存储在栈内存，存储的是值。  复杂数据类型存储在堆内存，存储的是地址。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。 

##  typeof 是否正确判断类型? instanceof呢？ instanceof 的实现原理是什么？如果都不能那么最好用什么方法呢

1. 不能,会将array判定为object
2. 不能 1 instanceof Number 为false
3. 判断左边的元素的prototype,是否等于构造函数的prototype
4. Object.prototype.toString.call(arg).slice(8,-1)

## for of , for in 和 forEach,map 的区别。

1. for of 调用的是该元素的iterator接口,一般返回的是值
2. for in 枚举当前元素的key
3. forEach 传递回调,回调的一个参数为value,第二个为index,性能最差
4. map,传递一个参数为value,index的回调,生成一个新的数组

## 如何判断一个变量是不是数组？

1. Array.isArray
2. Object.prototype.toString.call(ary)
3. ary instance Array

##  类数组和数组的区别是什么？

1. 类数组不是真正的数组,但是可以通过[...arrayLike]转换为新的数组
2.  不具有数组所具有的方法； 

##  == 和 === 有什么区别？

1. ==判定有类型转换,===没有
2. 相同的是都是将复杂类型转换为简单类型

## ES6中的class和ES5的类有什么区别？

1. 实际上是ES5的语法糖
2. 定义在constructor之外的方法,实际上相当于定义在prototype上,
3. class使用extends 继承
4.  ES6 class 必须使用 new 调用; 

##  数组的哪些API会改变原数组？

1. push 从数组尾部推入
2. pop 从数组尾部取出
3. shift 从数组头部取出
4. unshift 从数组头部推入
5. splice 删除位置,删除个数,插入个数

##  let、const 以及 var 的区别是什么？

1. let,const声明的变量有暂时性死区,不能重新声明,有块作用域,var可以重复声明,没有块作用域
2. let,var声明的变量能重新赋值,const不能

##  在JS中什么是变量提升？什么是暂时性死区？

1. 用var声明的变量,在js预编译阶段,会将变量提升到当前作用域的顶部
2. let,const声明的变量,没有变量提升,且在声明变量之前不能使用,使用则会抛出错误

## 如何正确的判断this? 箭头函数的this是什么？

1. this指向当前的调用者
2. 父级作用域中的this

## 谈谈你对JS执行上下文栈和作用域链的理解。

1. js在执行代码的时候,每当进入一个函数的执行,便会创建他的执行上下文,然后将他压入调用栈的顶部,执行完成后,弹出栈,进入垃圾回收

## 什么是闭包？闭包的作用是什么？闭包有哪些使用场景？

1. 闭包是当前作用域访问另一个作用域中的变量
2. 形成私有变量,只暴露公共接口

##  call、apply,bind有什么区别？call,aplly和bind的内部是如何实现的？

1. 都是改变当前this的指向

2. call是(obj,arg1,arg2)分别提供参数

3. apply是(obj,[arg1,arg2]) 提供一个数组

   ```JavaScript
   Function.prototype.call = function (context){
     context.fn = this;//在函数调用call的时候执行call
     const args = [...arguments].slice(1) //除开当前的context
     const result = context.fn(...args);
     delete context.fn
     return result
   }
   ```

4. call和apply都会直接执行,而bind是创建一个函数

   ```JavaScript
   Function.prototype.bind = function (context) {
     const fn = this;
     const args = [...arguments].slice(1);
     const Fn = function () {};
     Fn.prototype = fn.prototype;
     const newFunc = function () {
       return fn.apply(context, args);
     };
     newFunc.prototype = new Fn();
     return newFunc;
   };
   ```

   

## new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？

1. 将构造函数的this指向空对象

2. 创建的对象的prototype属性的constructor指向构造函数

   ```javascript
   function myNew(fn){
     const obj = {};
     const args = [...arguments].slice(1);
     fn.call(obj,...args);
     Object.setPrototypeOf(obj,fn.prototype);
     return obj
   }
   ```

##  谈谈你对原型的理解？

1. js中创建对象的时候,默认会创建一个prototype属性,这个属性指向该对象的原型,这个对象会继承该原型的属性和方法

## 什么是原型链？【原型链解决的是什么问题？】

1. 当访问一个对象的属性或者方法时候,默认先在该对象寻找,如果找不到,进入prototype寻找,如果还是找不到,再进入prototype的prototype,最后直到原型链顶层null,抛出错误
2. 可以多样化继承,继承的同时可以实现自己的特有方法和属性

##  prototype 和 `__proto__` 区别是什么？

1. prototype指向的是构造函数的原型
2. \_\_proto\_\_是每个实例拥有的原型,与构造函数的prototype指向的是同一个对象

## 使用ES5实现一个继承？

```JavaScript
 function Animal(age){
   this.age = age
 }
 function Cat(age,name){
   Animal.call(this,age);
   this.name = name;
 }
Cat.prototype = new Animal();
Cat.prototype.constrcutor = Cat; //instanceof 根据原型上的constructor判断的

```

##  什么是深拷贝？深拷贝和浅拷贝有什么区别？

1. 深拷贝就是拷贝引用类型数据的时候是复制的对象,而不是对象引用
2. 浅拷贝只是复制的引用

## 防抖和节流的区别是什么？防抖和节流的实现。

1. 防抖必须要间隔一定时间才能出发

2. 节流是一段时间只能触发一次

   ```javascript
   const debounceFactory=(delay)=>{
     let timer = null;
     return (callback)=>{
       clearTimeout(timer);
       timer = setTimeout(callback,delay)
     }
   }
   
   const throtllingFactory = (delay) =>{
     let preTime = Date.now();
     return (callback) =>{
       const nowTime = Date.now();
       if(nowTime-preTime>delay){
         preTime = nowTime;
         callback()
       }
     }
   }
   ```

## 取数组的最大值（ES5、ES6）

```javascript
//es6
Math.max(...ary);
//es5
Math.apply(null,ary)
ary.reduce((pre,cur)=>{
  return pre>cur?pre:cur;
})
```

## setTimeout倒计时为什么会出现误差？

1. 因为setTimeout是一个异步任务,当主线程执行完毕后,才会执行事件队列中的回调,所以时间是最小时间

##  为什么 0.1 + 0.2 != 0.3 ?

```
0.1 -> 0.0001100110011001...(无限循环)
0.2 -> 0.0011001100110011...(无限循环)
所以相加不会得到0.3
```

## promise 有几种状态, Promise 有什么优缺点 ?

1. 一共有fullfiled,rejected,pending三种状态
2. 优点是解决了回调地狱,缺点是无法取消

## Promise构造函数是同步还是异步执行，then中的方法呢 ?promise如何实现then处理 ?

1. promise是一个容器,实际上是同步执行的
2. then中的方法是异步执行的
3. 当promise中没有reject的时候,触发then方法

## 微任务与宏任务的区别

1. 宏任务在执行的过程中可以添加微任务

2. 在当前的微任务没有结束的时候不会执行下一个宏任务

3. 如下代码

   ```JavaScript
   setTimeout(_ => console.log(4))
   
   new Promise(resolve => {
     resolve()
     console.log(1)
   }).then(_ => {
     console.log(3)
   })
   
   console.log(2)
   
   //输出顺序
   //1 2 3 4
   ```

   

## Promise和setTimeout的区别 ?

1. promise是微任务
2. setTimeout是宏任务
3. 同一个事件循环中,promise比setTimeout先执行

## 如何实现 Promise.all ?

首先总结promise的特点

1. 一个rejected全部rejected
2. 返回参数是一个数组

```typescript
function promiseAll(promises: Promise<any>[]) {
  return new Promise((resolve, reject) => {
    const result = Array(promises.length);
    let position = 0;
    promises.forEach((v, index) => {
      v.then((data) => {
        result.splice(index, 1, data);
        position++;
        if (position === promises.length) {
          resolve(result);
        }
      }).catch((err) => {
        reject(err);
      });
    });
  });
}
```



## 什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和

函数柯里化,是函数式编程常见的方法,是将多个参数收集起来,直到参数收集完全再执行

```typescript
const curryFunc = (fn: Function) => {
  const judge = (...args: any) =>
    fn.length === args.length
      ? fn(...args)
      : (...arg: any) => judge(...args, ...arg);
  return judge; 
};
```

