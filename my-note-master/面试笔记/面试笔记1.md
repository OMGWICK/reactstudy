# 原生 JS

## 异步理解

在传递回调后,异步事件完成后,通知主线程,放入执行队尾,

## new 实现

```js
function myNew(constructor, ...args) {
  let obj = {};
  if (typeof constructor === 'function') {
    constructor.call(obj, ...args);
  } else {
    throw new TypeError('need constructor');
  }
  Object.setPrototypeOf(obj, constructor.prototype);
  return obj;
}
```

## extends class 继承

```js
function Person(name) {
  this.name = name;
}
function Tom(name, age) {
  check(this, Tom);
  inheritFather(Tom, Person);
  Person.call(this, name);
  this.age = age;
}
function check(o, p) {
  if (!(o instanceof p)) {
    throw new Error('new');
  }
}

function inheritFather(subClass, superClass) {
  Object.setPrototypeOf(subClass.prototype, superClass.prototype);
}
```

## reduce

```typescript
//Array.prototype.reduce=function((accumulator,currentValue,currentIndex?,thiAry?)=>value,initValue)

const a = [1, 2];
const b = {
  reduce(callback: Callback, initValue?: any) {
    let k = 1;
    let result = initValue || this[0];
    if (this.length === 0) {
      throw new Error('Reduce of empty array with no initial value');
    }
    while (k < this.length) {
      result = callback(result, this[k], k, this);
      k++;
    }
    return result;
  },
};
Object.setPrototypeOf(a, b);
type Callback = (
  accumulator: any,
  currentValue: any,
  currentIndex?: number,
  thisAry?: any[]
) => any;
console.log(a.reduce((c, v) => c + v));
```

## Object.create

```typescript
Object.create = function (obj: Object) {
  let newObj = {};
  Object.setPrototypeOf(newObj, obj);
  return newObj;
};
```

## Array.isArray

```typescript
function isArray(arg: any): boolean {
  const result = (Object.prototype.toString.call(arg) as string).slice(8, -1);
  if (result === 'Array') {
    return true;
  }
  return false;
}
```

## instanceof

```typescript
function instanceOf(o1: object, o2: Function) {
  let proto = Object.getPrototypeOf(o1);
  if (typeof o2 !== 'function') {
    throw new Error('Right-hand side of instanceof is not callable');
  }
  while (proto !== null) {
    if (proto === o2.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}
```

## 防抖 debounce

在触发时间的 n 秒后再执行回调,如果这段时间事件再次触发则重新计时

也就是在事件结束后触发真正的函数,延迟一段时间执行

```typescript
const debonce = debounceFactory(1000);
window.addEventListener('scroll', (e) => {
  debonce(() => {
    console.log(e);
  });
});

function debounceFactory(delay: number = 100) {
  let timer = null;
  return (callback: Function) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      callback();
    }, delay);
  };
}
```

## 节流 throttling

在一段时间内只能执行 1 次,在这个例子中简而言之就是,下次滑动的时候比上次滑动已经过去了 1000ms 以上函数才会执行

```typescript
const throttling = throttlingFactory();
window.addEventListener('scroll', (e) => {
  throttling(() => {
    console.log(e);
  });
});

function throttlingFactory(delay: number = 1000) {
  let preTime = Date.now();
  return (callback: Function) => {
    let curTime = Date.now();
    if (curTime - preTime > delay) {
      callback();
      preTime = curTime;
    }
  };
}
```

## curry 柯里化函数

用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，开始执行函数

```typescript
const curry = (fn: Function) => {
  const judge = <T>(...args: T[]) =>
    args.length === fn.length
      ? fn(...args)
      : (...arg: T[]) => judge(...args, ...arg);
  return judge;
};

const sum = (a: number, b: number, c: number, d: number) => a + b + c + d;
const currySum = curry(sum);

currySum(1)(2)(3)(4); // 10
currySum(1, 2)(3)(4); // 10
currySum(1)(2, 3)(4); // 10
```

## 深拷贝

```JavaScript
var map = new Map([
  ['Object', depObject],
  ['Array', depArray],
]);
function depCopy(arg) {
  var type = Object.prototype.toString.call(arg).slice(8, -1);
  var func = map.get(type);
  if (arg instanceof Element) {
    return arg;
  }
  if (func) {
    return func(arg);
  }
  return arg;
}
function depObject(obj) {
  var result = {};
  for (var _i = 0, _a = Object.entries(obj); _i < _a.length; _i++) {
    var _b = _a[_i],
      key = _b[0],
      value = _b[1];
    result[key] = value;
  }
  return result;
}
function depArray(ary) {
  var result = [];
  for (var i in ary) {
    result[i] = ary[i];
  }
  return result;
}

console.log(depCopy([]));

```

# Vue

## Vue 数据绑定的原理是什么？

```javascript
//残次版本,订阅者模式没实现
class Vue {
  constructor(options) {
    let { el, data } = options;
    this.el = el;
    this['$data'] = data;
    Object.entries(data).forEach((e) => {
      this[e[0]] = e[1];
    });
    Object.keys(this).forEach((e) => {
      if (e !== 'el' && e !== '$data') {
        Reflect.defineProperty(this, e, {
          get() {
            return this['$data'][e];
          },
          set(v) {
            compiler.call(this, e, v);
            this['$data'][e] = v;
          },
        });
      }
    });
    this['$el'] = mountHtml(el);
    compiler.call(this, this['$el']);
  }
  converData(r) {
    let data = r.replace(/{{|}}/g, '');
    return this[data];
  }
}
function mountHtml(el) {
  return document.querySelector(el);
}
function compiler(el, value) {
  if (el.nodeType === 1) {
    let result = el.outerHTML.match(/{{[\s\S]*?}}/g);
    result.forEach((r) => {
      el.innerHTML = el.innerHTML.replace(r, this.converData(r));
    });
    let children = [...el.children];
    children.forEach((ele) => {
      if (ele.getAttribute('v-model')) {
        if (!value) {
          value = this[ele.getAttribute('v-model')];
          ele.value = value;

          ele.addEventListener('input', () => {
            this[ele.getAttribute('v-model')] = ele.value;
          });
        }
      }
    });
  } else {
  }
}
let vm = new Vue({
  el: '#app',
  data: {
    msg: 'hello',
    text: 'world',
  },
});
```

## proxy 双向绑定

```typescript
function twoBinding<T extends object>(target: T) {
  const proxy: T = new Proxy(target, {
    get(target, p) {
      return target[p];
    },
    set(target, p, value) {
      //这里进行dom操纵
      return Reflect.defineProperty(target, p, {
        value,
      });
    },
  });
  return proxy;
}

let obj = twoBinding({ a: 1 });
obj.a = 3;
console.log(obj);
```

# React

## HOC,hook,render props 的区别

1. HOC 是高阶组件,是一个参数为组件,返回值为新组件的函数,例如 redux 的`connect` 抽离共通的逻辑部分,缺点是,这个函数不会告诉你组件中包括了哪些 props

   ```jsx
   const OtherElement = wrapper(thisElement);
   ```

1. render props 将一个组件的 state 作为 props 传递给调用者,

   ```jsx
   //复用获取鼠标坐标组件.
   class Mouse extends React.Component {
     constructor(props) {
       super(props);
       this.state = { x: 0, y: 0 };
     }

     render() {
       return (
         <div style={{ height: '100%' }}>
           // 使用 render props 属性来确定要渲染的内容
           {this.props.render(this.state)}
         </div>
       );
     }
   }
   // 调用方式:
   <Mouse
     render={(mouse) => (
       <p>
         鼠标的位置是 {mouse.x}，{mouse.y}
       </p>
     )}
   />;
   ```

1. hook

   ```jsx
   const { x, y } = useMouse();
   const { x: pageX, y: pageY } = usePage();

   useEffect(() => {}, [pageX, pageY]);
   ```

## React 中的 Fiber 到底是什么？

# Css

## 移动端

### 设备独立像素(DIP)

以 chrome 控制台的 ipone678 为例这里的 375\*667 就是独立像素

![img](https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcZyMhOgCZPJXfAibjFubIsO7x0jJDTWyZK3wdtbYPv3UzUF8jVmNDbldLFhTOrZLT8MibbafYwLacEA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

设备独立像素= css 像素=逻辑像素

### 物理像素(PT)

物理像素是不变的,相当于电脑的 1920\*1080 一个性质![img](https://mmbiz.qpic.cn/mmbiz_png/eXCSRjyNYcZyMhOgCZPJXfAibjFubIsO7AQzdVfsIicCrqHmZxKARibJ1vKZ3RpWIibeOBnSib1CghJeAEI6cMicFT5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### DPR 设备像素比

设备像素比的计算公式是 **DPR = 物理像素 / 设备独立像素**,例如 DPR = 1334/667 = 2,这也叫视网膜屏幕(DPR>1),在视网膜屏幕上,以 DPR=2 为例,会把 4(2\*2)个像素当 1 个像素使用

### rem 适配

通过 document.documentElement.style.fontSize = document.documentElement.clientWidth 动态修改 html 的 fontsize 来使用 rem 进行布局

### vw 布局

<font color='red'>**注意只能用来做移动端,因为在 pc 端滚动条不算在 window.innerWidth 之内**</font>

`1vw` = `window.innerWidth`

`1vh` = `window.innerHeight`

## 字体适配

浏览器有最小字体限制：

- PC 上最小 font-size=12px
- 手机上最小 font-size=8px
