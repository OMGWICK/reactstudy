# JavaScript数据结构

## 栈 stack

后进先出 LIFO `leave in first out`  **进栈出栈**

```typescript
class Stack {
  private count: number;
  private _items = Symbol('items');
  constructor() {
    this.count = 0;
    // this.items = {};
    //修改为外部不能修改,和只能通过特定接口
    this[this._items] = {};
  }
  push(element) {
    this[this._items][this.count++] = element;
  }
  pop() {
    const element = this[this._items][--this.count];
    delete this[this._items][this.count];
    return element;
  }
  peek() {
    return this[this._items][this.count];
  }
  isEmpty() {
    return this.count === 0;
  }
  clear() {
    this.count = 0;
    this[this._items] = {};
    //也可以使用LIFO原则
    // while (!this.isEmpty()) {
    //   this.pop();
    // }
  }
  size() {
    return this.count;
  }
  toString() {
    if (this.isEmpty()) {
      return '';
    } else {
      let objString = '';
      for (let i = 0; i < this.count; i++) {
        objString += ` ${i}=>${this[this._items][i]} `;
      }
      return objString;
    }
  }
}
```



### 进制转换

```typescript
const MyStack = require('./stack/stack-object');

function baseConverter(num, hex) {
  const stack = new MyStack();
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  let result = num;
  let string = '';
  while (result > 0) {
    stack.push(result % hex);
    result = Math.floor(result / hex);
  }
  while (!stack.isEmpty()) {
    string += digits[stack.pop()];
  }
  return string;
}

console.log(baseConverter(100345, 35));

```

## 队列 queue

先进先出 FIFO `frist in frist out`  **入队,出队**

```typescript
class Queue {
  private items: object;
  private count: number;
  private lowerCount: number;
  constructor() {
    this.items = {};
    this.count = 0;
    this.lowerCount = 0;
  }
  enqueue(element: any) {
    //向队尾添加元素
    this.items[this.count++] = element;
  }
  dequeue() {
    //删除队列第一项并返回
    const element = this.items[this.lowerCount];
    delete this.items[this.lowerCount];
    this.lowerCount++;
    return element;
  }
  peek() {
    //查询队列第一个元素
    return this.items[this.lowerCount];
  }
  isEmpty() {
    return this.count - this.lowerCount === 0;
  }
  size() {
    return this.count - this.lowerCount;
  }
  toString() {
    if (this.isEmpty()) {
      return '';
    }
    return Object.entries(this.items)
      .map(([key, value]) => key + '=>' + value)
      .toString();
  }
}
```

## 双端队列 deque

```typescript
class Deque<T> {
  private items: any;
  private count: number;
  private lowerCount: number;
  constructor() {
    this.items = {};
    this.count = 0;
    this.lowerCount = 0;
  }
  isEmpty() {
    return this.size() === 0;
  }
  clear() {
    this.items = {};
    this.count = 0;
    this.lowerCount = 0;
  }
  size() {
    return this.count - this.lowerCount;
  }
  toString() {
    if (this.isEmpty()) {
      return '';
    }
    return Object.entries(this.items)
      .map(([key, value]) => key + '=>' + value)
      .toString();
  }
  addFront(element: T) {
    //添加到双端队列的前端
    if (this.isEmpty()) {
      this.addBack(element);
      return;
    } else if (this.lowerCount > 0) {
      this.items[--this.lowerCount] = element;
      return;
    }
    for (let i = this.count; i > 0; i--) {
      this.items[i + 1] = this.items[i];
    }
    this.items[this.lowerCount] = element;
    this.count++;
  }
  addBack(element: T) {
    //添加到双端队列的后端
    this.items[this.count++] = element;
  }
  removeFront() {
    if (this.isEmpty()) {
      return false;
    }
    const element = this.items[this.lowerCount];
    delete this.items[this.lowerCount++];
    return element;
  }
  removeBack() {
    if (this.isEmpty()) {
      return false;
    }
    const element = this.items[this.count - 1];
    delete this.items[--this.count];
    return element;
  }
  peekFront() {
    //展示前端
    return this.items[this.lowerCount];
  }
  peekBack() {
    //展示后端
    return this.items[this.count];
  }
}
```

### 击鼓传花

```typescript
const persons = ['张飞', '刘备', '关羽', '诸葛亮', '孙权', '周瑜', '大乔'];
//这里使用的队列是对象版本的
function hotPotato<T>(elements: T[], sum: number) {
  const queue = new Queue();
  const logSum = sum;
  let result = '';
  elements.forEach((value) => {
    queue.enqueue(value);
  });
  while (sum !== 0) {
    queue.enqueue(queue.peek());
    queue.dequeue();
    sum--;
    if (sum === 0) {
      result += `${queue.dequeue()}被淘汰\n`;
      if (queue.size() !== 1) {
        sum = logSum;
      }
    }
  }
  result += `winner is ${queue.peek()}`;
  return result;
}

console.log(hotPotato(persons, 5));


function hotPotato(elements: string[], num: number) {
  while (elements.length > 1) {
    for (let i = 0; i < num; i++) {
      elements.push(elements.shift() || '');
    }
    console.log(`${elements.shift()}被淘汰`);
  }
  return elements[0];
}

```

### 回文

```typescript
function huiCheck(str: string) {
  const ary = str.split('');
  while (ary.length !== 0) {
    if (ary.pop() !== ary.shift()) {
      return false;
    }
    if (ary.length === 1) {
      return true;
    }
  }
  return true;
}

function huiCheck(str: string) {
  return str === str.split('').reverse().join('');
}

console.log(huiCheck('1211'));

```

## 链表

```typescript
import defaultEqualsFn from './defaultEqualsFn';
import MNode from './node';

class LinkedList {
  private count: number;
  private equalsFn: (a: any, b: any) => boolean;
  private head: MNode;
  constructor(equalsFn = defaultEqualsFn) {
    //存储元素数量
    this.count = 0;
    //因为链表是动态的,所以需要一个地方来放头部的引用
    this.head = null;
    this.equalsFn = equalsFn;
  }
  push(element: any) {
    //向链表尾部添加元素
    const node = new MNode(element);
    let current: MNode;
    if (this.head === null) {
      this.head = node;
    } else {
      current = this.head;
      //遍历链表
      while (current.next !== null) {
        current = current.next;
      }
      //建立连接
      current.next = node;
    }
    this.count++;
  }
  insert(element: any, position: number) {
    const node = new MNode(element);
    let current = this.head;
    if (position === 0) {
      node.next = current;
      this.head = node;
      return;
    }
    //获取插入位置的前一个
    current = this.getElementAt(position - 1);
    //重新组装
    node.next = current.next;
    current.next = node;
    this.count++;
  }
  getElementAt(index: number) {
    let postion = 0;
    let current = this.head;
    if (!current) {
      return;
    }
    if (this.isEmpty()) {
      return;
    }
    while (postion !== index) {
      current = current.next;
      postion++;
    }
    return current;
  }
  remove(element: any) {
    let current = this.head;
    if (!current) {
      return;
    }
    if (this.equalsFn(current.element, element)) {
      this.count--;
      this.head = current.next;
      return current.element;
    }
    while (current.next !== null) {
      if (this.equalsFn(element, current.next.element)) {
        const result = current.next;
        current.next = current.next.next;
        this.count--;
        return result;
      }
    }
    return;
  }
  removeAt(index: number) {
    let position = 0;
    let current = this.head;
    if (!current) {
      return;
    }
    if (index === 0) {
      this.head = current.next;
      this.count--;
      return current;
    }
    while (index < this.count && position !== index - 1) {
      current = current.next;
      position++;
    }
    if (position === index - 1) {
      const result = current.next;
      current.next = current.next.next;
      this.count--;
      return result;
    }
    return;
  }
  indexOf(element: any) {
    let current = this.head;
    let postion = 0;
    if (!current) {
      return -1;
    }
    while (postion < this.count && !this.equalsFn(element, current.element)) {
      current = current.next;
      postion++;
    }
    if (this.equalsFn(element, current.element)) {
      return postion;
    }
    return -1;
  }
  toString() {
    if (this.isEmpty()) {
      return '';
    }
    let current = this.head;
    let string = current.element.toString();
    while (current.next !== null) {
      string = `${string},${current.element}`;
      current = current.next;
    }
    return string;
  }
  size() {
    return this.count;
  }
  isEmpty() {
    return this.count === 0;
  }
}

//defaultEqualFn.js
export default (a: any, b: any) => {
  return a === b;
};

//node.js

export default class Node {
  public next: Node;
  constructor(public element: any) {
    this.element = element;
    //指向下一个元素的指针
    this.next = null;
  }
}

```

## 集合

存储的互不相同的元素

```typescript
class MySet {
  private items: { [x: string]: any; [y: number]: any };
  constructor() {
    this.items = {};
  }
  add(element: string | number) {
    if (this.has(element)) {
      return false;
    }
    this.items[element] = element;
    return true;
  }
  has(element: any) {
    // return element in this.items;
    return this.items.hasOwnProperty(element);
  }
  delete(element: string | number) {
    if (!this.has(element)) {
      return false;
    }
    return delete this.items[element];
  }
  clear() {
    this.items = {};
  }
  size() {
    return Object.keys(this.items).length;
  }
  values() {
    return Object.values(this.items);
  }
  union(otherSet: MySet) {
    const unionSet = new MySet();
    [...this.values(), ...otherSet.values()].forEach((v) => {
      unionSet.add(v);
    });
    return unionSet;
  }
  intersection(otherSet: MySet) {
    const intersectionSet = new MySet();
    // this.values().forEach((v) => {
    //   otherSet.values().forEach((result) => {
    //     if (result === v) {
    //       intersectionSet.add(v);
    //     }
    //   });
    // });
    this.values().forEach((v) => {
      if (otherSet.has(v)) {
        intersectionSet.add(v);
      }
    });
    return intersectionSet;
  }
  diffrence(otherSet: MySet) {
    const diffrenceSet = new MySet();
    this.values().forEach((v) => {
      if (!otherSet.has(v)) {
        diffrenceSet.add(v);
      }
    });
    return diffrenceSet;
  }
  isSubSetOf(otherSet: MySet) {
    const ary = this.values();
    for (let i = 0; i < ary.length; i++) {
      if (!otherSet.has(ary[i])) {
        return false;
      }
    }
    return true;
  }
}
```

## 字典

和集合的区别是存储的是键值对

```typescript
class Dictionary {
  public table: { [x: string]: any };
  constructor() {
    this.table = {};
  }
  set(key: string, value: any) {
    this.table[key] = value;
  }
  remove(key: string) {
    if (this.hasKey(key)) {
      delete this.table[key];
      return true;
    }
    return false;
  }
  hasKey(key: string) {
    return key in this.table;
  }
  get(key: string) {
    return this.table[key];
  }
  clear() {
    this.table = {};
  }
  size() {
    return Object.keys(this.table).length;
  }
  isEmpty() {
    return this.size() === 0;
  }
  keys() {
    return Object.keys(this.table);
  }
  values() {
    return Object.values(this.table);
  }
  keyValues() {
    return Object.entries(this.table);
  }
  forEach(callbackFn: (value: any, key: string) => any) {
    const ary = this.keyValues();
    for (let i in ary) {
      if (callbackFn(ary[i][1], ary[i][0]) === false) {
        return;
      }
    }
  }
}
```

## 散列表 HashTable HashMap

1.因为有可能hashCode会相同

```typescript
class HashMap {
  private table: { [x: string]: ValuePair };
  constructor() {
    this.table = {};
  }
  put(key: string, value: any) {
    this.table[this.hashCode(key)] = new ValuePair(key, value);
  }
  remove(key: string) {
    if (this.get(key)) {
      delete this.table[this.hashCode(key)];
      return true;
    }
    return false;
  }
  get(key: string) {
    const valuePair = this.table[this.hashCode(key)];
    return valuePair && valuePair.value;
  }
  hashCode(key: string) {
    return (
      key.split('').reduce((pre, cur) => {
        return pre + cur.charCodeAt(0);
      }, 0) % 37 //除以任意数字的目的是规避操作数超过最大数字的风险
    );
  }
}

class ValuePair {
  constructor(public key: string, public value: any) {
    this.key = key;
    this.value = value;
  }
}
```

### 分离链接

使用链表,当该位置被占用的时候,挂载到第一个的next上

### 线性探查

当被占用的时候,就使用position+1,如果postition+1也被占用了,那就+2,直到找到空闲位置

```typescript
class HashMap {
  private table: { [x: string]: ValuePair };
  constructor() {
    this.table = {};
  }
  put(key: string, value: any) {
    let position = this.hashCode(key);
    while (this.has(position)) {
      position++;
    }
    this.table[position] = new ValuePair(key, value);
  }
  remove(key: string) {
    if (this.get(key)) {
      const position = this.indexOf(key);
      delete this.table[position];
      this.verifyRemoveEffect(key, position);
      return true;
    }
    return false;
  }
  get(key: string) {
    const position = this.indexOf(key);
    return this.table[position].value;
  }
  private verifyRemoveEffect(key: string, initPosition: number) {
    //指针指向删除元素的下一个元素
    let position = initPosition + 1;
    let changePosition = position - 1;
    while (this.has(position)) {
      if (this.hashCode(this.table[position].key) <= this.hashCode(key)) {
        this.table[changePosition] = this.table[position];
        changePosition = position;
        delete this.table[position];
      }
      console.log(position);
      position++;
    }
  }
  private hashCode(key: string) {
    return (
      key.split('').reduce((pre, cur) => {
        return pre + cur.charCodeAt(0);
      }, 0) % 37 //除以任意数字的目的是规避操作数超过最大数字的风险
    );
  }
  has(position: number) {
    return position.toString() in this.table;
  }
  private indexOf(key: string) {
    //如果在当前位置有被删除的,例如hashCode为5,然后被删除,空余位置会影响性能
    //有副作用的只有可能是hash值比当前小的
    let position = this.hashCode(key);
    while (this.table[position]?.key !== key) {
      position++;
    }
    return position;
  }
}

class ValuePair {
  constructor(public key: string, public value: any) {
    this.key = key;
    this.value = value;
  }
}
```



### 双散列法

## 递归

## 迭代阶乘

```typescript
function factorial(num: number): number {
  if (num > 1) {
    return num * factorial(num - 1);
  }
  return 1;
}
```

## 斐波那契数列

任意一个自然数都有它的斐波那契数,采用递归求出

```typescript
function fib(N: number): number {
    if(N===0){
        return 0;
    }else if(N===1){
        return 1;
    }else{
        return fib(N-1)+fib(N-2)
    }
};
```

记忆化斐波那契

```typescript
function memoFib(num: number) {
  if (num < 1) {
    return 0;
  }
  const memo = [0, 1];
  const fib = (n: number): number => {
    if (memo[n] !== undefined) {
      return memo[n];
    }
    return (memo[n] = fib(n - 1) + fib(n - 2));
  };
  return fib(num);
}
```

## 二叉搜索树

```typescript
class MyNode<K> {
  public left: MyNode<K> | null;
  public right: MyNode<K> | null;
  constructor(public key: K) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree<T> {
  public root: MyNode<T> | null;
  constructor() {
    this.root = null;
  }
  insert(key: T) {
    if (!this.root) {
      this.root = new MyNode(key);
      return;
    } else {
      this.insertNode(this.root, key);
    }
  }
  search(key: T): boolean {
    if (this.root === null) {
      return false;
    }
    return this.searchNode(this.root, key);
  }
  /**
   * 中序遍历是以上行顺序访问BST所有节点的遍历方式,也就是从小到大遍历
   * 传递回调访问者模式
   */
  inOrderTraverse(callback: (value: T) => any) {
    this.inOrderTraverseNode(this.root, callback);
  }
  /**
   * 先序遍历是以优先后代节点的顺序遍历节点
   */
  preOrderTraverse(callback: (value: T) => any) {
    this.preOrderTraverseNode(this.root, callback);
  }
  /**
   * 后序遍历是以优先后代节点的顺序遍历节点,先访问厚点
   */
  postOrderTraverse(callback: (value: T) => any) {
    this.postOrderTraverseNode(this.root, callback);
  }
  /**
   * 获取最大值
   */
  min() {
    if (this.root === null) {
      return;
    }
    return this.minNode(this.root).key;
  }
  /**
   * 获取最大值
   */
  max() {
    if (this.root === null) {
      return;
    }
    return this.maxNode(this.root).key;
  }
  /**
   * 删除节点
   */
  remove(key: T) {
    this.root = this.removeNode(this.root, key);
  }
  private removeNode(node: MyNode<T> | null, key: T): MyNode<T> | null {
    if (node === null) {
      return null;
    }
    if (key < node.key) {
      node.left = this.removeNode(node.left, key);
      return node;
    } else if (key > node.key) {
      node.right = this.removeNode(node.right, key);
      return node;
    } else {
      if (node.left === null && node.right === null) {
        node = null;
        return node;
      }
      if (node.left === null) {
        node = node.right;
        return node;
      } else if (node.right === null) {
        node = node.left;
        return node;
      }
    }
    const crx = this.minNode(node.right);
    node.key = crx.key;
    node.right = this.removeNode(node.right, crx.key);
    return node;
  }
  private maxNode<K>(node: MyNode<T>): MyNode<T> {
    if (node.right === null) {
      return node;
    } else {
      return this.maxNode(node.right);
    }
  }
  private minNode(node: MyNode<T>): MyNode<T> {
    if (node.left === null) {
      return node;
    } else {
      return this.minNode(node.left);
    }
  }
  private preOrderTraverseNode(node: MyNode<T> | null, callback: Function) {
    if (node !== null) {
      callback(node.key);
      this.preOrderTraverseNode(node.left, callback);
      this.preOrderTraverseNode(node.right, callback);
    }
  }
  private inOrderTraverseNode(node: MyNode<T> | null, callback: Function) {
    if (node !== null) {
      this.inOrderTraverseNode(node.left, callback);
      callback(node.key);
      this.inOrderTraverseNode(node.right, callback);
    }
  }
  private postOrderTraverseNode(node: MyNode<T> | null, callback: Function) {
    if (node !== null) {
      this.postOrderTraverseNode(node.left, callback);
      this.postOrderTraverseNode(node.right, callback);
      callback(node.key);
    }
  }
  private insertNode(node: MyNode<T>, key: T) {
    if (node.key < key) {
      if (node.right === null) {
        node.right = new MyNode(key);
      } else {
        this.insertNode(node.right, key);
      }
    } else {
      if (node.left === null) {
        node.left = new MyNode(key);
      } else {
        this.insertNode(node.left, key);
      }
    }
  }
  private searchNode(node: MyNode<T> | null, key: T): boolean {
    if (node === null) {
      return false;
    }
    if (node.key === key) {
      return true;
    }
    if (node.key < key) {
      return this.searchNode(node.right, key);
    } else {
      return this.searchNode(node.left, key);
    }
  }
}
```

## 二叉平衡树 AVL

AVL是一种平衡树

```typescript
class AVLTree extends BinarySearchTree<number> {
  constructor() {
    super();
    this.root = null;
  }
  private getNodeHeight(node: MyNode<number> | null): number {
    if (node === null) {
      return -1;
    }
    return (
      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +
      1
    );
  }
  insert(key: number) {
    this.root = this.insertNode(this.root, key);
  }
  protected insertNode(
    node: MyNode<number> | null,
    key: number
  ): MyNode<number> {
    if (node === null) {
      return new MyNode(key);
    } else if (node.key < key) {
      node.right = this.insertNode(node.right, key);
    } else if (node.key > key) {
      node.left = this.insertNode(node.left, key);
    }
    node = this.tryBalanceNode(node, key);
    return node;
  }
  /**
   *
   * @param node
   */
  private tryBalanceNode(node: MyNode<number>, key: number) {
    const balanceFactor = this.getBalanceFactor(node);
    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
      if (key < ((node.left && node.left.key) || -1)) {
        node = this.rotationLL(node);
        node = this.tryBalanceNode(node, key);
        return node;
      } else {
        return this.rotationLR(node);
      }
    }
    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
      if (key > ((node.left && node.left.key) || -1)) {
        node = this.rotationRR(node);
        node = this.tryBalanceNode(node, key);
        return node;
      } else {
        return this.rotationRL(node);
      }
    }
    return node;
  }
  remove(key: number) {
    this.root = this.removeNode(this.root, key);
  }
  protected removeNode(node: MyNode<number> | null, key: number) {
    node = super.removeNode(node, key);
    if (node === null) {
      return node;
    }
    node = this.tryBalanceNode(node, key);
    return node;
  }
  /**
   * 获取平衡因子
   */
  private getBalanceFactor(node: MyNode<number>) {
    const heightDifference =
      this.getNodeHeight(node.left) - this.getNodeHeight(node.right);
    switch (heightDifference) {
      case -2:
        return BalanceFactor.UNBALANCED_RIGHT;
      case -1:
        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;
      case 1:
        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;
      case 2:
        return BalanceFactor.UNBALANCED_LEFT;
      default:
        return BalanceFactor.BALANCED;
    }
  }
  /**
   * LL
   * 左边大于右边且左边子节点更重
   * 右旋转
   */
  private rotationLL(node: MyNode<number>) {
    const tmp = node.left;
    if (tmp === null) {
      return node;
    }
    node.left = tmp.right;
    tmp.right = node;
    return tmp;
  }
  /**
   * RR
   * 右边大于左边且右边子节点更重
   * 左旋转
   */
  private rotationRR(node: MyNode<number>) {
    const tmp = node.right;
    if (tmp === null) {
      return node;
    }
    node.right = tmp.left;
    tmp.left = node;
    return tmp;
  }
  /**
   * LR
   * 左侧大于右侧且左侧子节点右侧较为重
   * 先将左侧子节点的右侧修复,采用左旋转,再采用右旋转修复根节点
   */
  private rotationLR(node: MyNode<number>) {
    if (node.left) {
      node.left = this.rotationRR(node.left);
    }
    return this.rotationLL(node);
  }
  /**
   * RL
   * 右侧大于左侧且右侧子节点左侧较为重
   */
  private rotationRL(node: MyNode<number>) {
    if (node.right) {
      node.right = this.rotationRR(node.right);
    }
    return this.rotationLL(node);
  }
}
```

